/*
Deployment script for Rogge.Track.Svr

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar SSISDB "SSISDB"
:setvar DatabaseName "Rogge.Track.Svr"
:setvar DefaultFilePrefix "Rogge.Track.Svr"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating database $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)] COLLATE SQL_Latin1_General_CP1_CI_AS
GO
USE [$(DatabaseName)];


GO
ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER 
    WITH ROLLBACK IMMEDIATE
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY SIMPLE,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION ON;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY CHECKSUM,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION FORCED,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = ALL, DATA_FLUSH_INTERVAL_SECONDS = 900, INTERVAL_LENGTH_MINUTES = 60, MAX_PLANS_PER_QUERY = 200, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE = OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = OFF;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET TEMPORAL_HISTORY_RETENTION ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
PRINT N'Creating Schema [track]...';


GO
CREATE SCHEMA [track]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [verf]...';


GO
CREATE SCHEMA [verf]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Table [track].[ApplicationLogBegin]...';


GO
CREATE TABLE [track].[ApplicationLogBegin] (
    [ApplicationLogId]       INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [ClassName]              VARCHAR (128)      NOT NULL,
    [FunctionName]           VARCHAR (128)      NOT NULL,
    [ApplicationVersion]     VARCHAR (128)      NOT NULL,
    [ApplicationPlatform]    VARCHAR (128)      NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     NOT NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ApplicationLogBegin] PRIMARY KEY CLUSTERED ([ApplicationLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ApplicationLogEnd]...';


GO
CREATE TABLE [track].[ApplicationLogEnd] (
    [ApplicationLogId] INT                NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ApplicationLogEnd] PRIMARY KEY CLUSTERED ([ApplicationLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ApplicationLogErrors]...';


GO
CREATE TABLE [track].[ApplicationLogErrors] (
    [ApplicationLogId] INT                NOT NULL,
    [ErrorMessage]     NVARCHAR (MAX)     NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ApplicationLogErrors] PRIMARY KEY CLUSTERED ([ApplicationLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ApplicationLogOrphans]...';


GO
CREATE TABLE [track].[ApplicationLogOrphans] (
    [ApplicationLogId]       INT                NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     NOT NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ApplicationLogOrphans] PRIMARY KEY CLUSTERED ([ApplicationLogId] ASC)
);


GO
PRINT N'Creating Table [track].[BatchLogBegin]...';


GO
CREATE TABLE [track].[BatchLogBegin] (
    [BatchLogId]             INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [SchemaName]             NVARCHAR (128)     NOT NULL,
    [TableName]              NVARCHAR (128)     NOT NULL,
    [QualifiedName]          AS                 QUOTENAME([SchemaName]) + N'.' + QUOTENAME([TableName]) PERSISTED NOT NULL,
    [SourceData]             NVARCHAR (128)     NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     NOT NULL,
    [txInsertedProcedure]    NVARCHAR (517)     NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_BatchLogBegin] PRIMARY KEY CLUSTERED ([BatchLogId] ASC)
);


GO
PRINT N'Creating Table [track].[BatchLogEnd]...';


GO
CREATE TABLE [track].[BatchLogEnd] (
    [BatchLogId]       INT                NOT NULL,
    [UpdateBeg]        DATETIMEOFFSET (7) NOT NULL,
    [UpdateEnd]        DATETIMEOFFSET (7) NULL,
    [RowCount]         INT                NOT NULL,
    [SourceNotes]      VARCHAR (MAX)      NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [PK_BatchLogEnd] PRIMARY KEY CLUSTERED ([BatchLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ProcedureLogBegin]...';


GO
CREATE TABLE [track].[ProcedureLogBegin] (
    [ProcedureLogId]         INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [schema_id]              INT                NOT NULL,
    [object_id]              INT                NOT NULL,
    [SchemaName]             NVARCHAR (128)     NOT NULL,
    [ObjectName]             NVARCHAR (128)     NOT NULL,
    [QualifiedName]          AS                 QUOTENAME([SchemaName]) + N'.' + QUOTENAME([ObjectName]) PERSISTED NOT NULL,
    [SPID]                   SMALLINT           NOT NULL,
    [NestLevel]              INT                NOT NULL,
    [TransactionCount]       INT                NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     NOT NULL,
    [txInsertedProcedure]    NVARCHAR (517)     NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ProcedureLogBegin] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ProcedureLogEnd]...';


GO
CREATE TABLE [track].[ProcedureLogEnd] (
    [ProcedureLogId]   INT                NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ProcedureLogEnd] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ProcedureLogErrors]...';


GO
CREATE TABLE [track].[ProcedureLogErrors] (
    [ProcedureLogId]   INT                NOT NULL,
    [ErrorNumber]      INT                NOT NULL,
    [ErrorSeverity]    INT                NOT NULL,
    [ErrorState]       INT                NOT NULL,
    [ErrorProcedure]   NVARCHAR (128)     NOT NULL,
    [ErrorLine]        INT                NOT NULL,
    [ErrorMessage]     NVARCHAR (MAX)     NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ProcedureLogErrors] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ProcedureLogIntermediate]...';


GO
CREATE TABLE [track].[ProcedureLogIntermediate] (
    [ProcedureLogIntermediateId] INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [ProcedureLogId]             INT                NOT NULL,
    [ProcedureLineNumber]        INT                NOT NULL,
    [ProcedureMessage]           VARCHAR (256)      NOT NULL,
    [txInserted]                 DATETIMEOFFSET (7) NOT NULL,
    [txInsertedProcedure]        NVARCHAR (517)     NULL,
    [txRowReplication]           UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]               ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ProcedureLogIntermediate] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC, [ProcedureLogIntermediateId] ASC)
);


GO
PRINT N'Creating Table [track].[ProcedureLogOrphans]...';


GO
CREATE TABLE [track].[ProcedureLogOrphans] (
    [ProcedureLogId]         INT                NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     NOT NULL,
    [txInsertedProcedure]    NVARCHAR (517)     NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ProcedureLogOrphans] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC)
);


GO
PRINT N'Creating Table [track].[SsisLogDetail]...';


GO
CREATE TABLE [track].[SsisLogDetail] (
    [SsisLogDetailId]        INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [Event]                  [sysname]          NOT NULL,
    [Computer]               NVARCHAR (128)     NOT NULL,
    [Operator]               NVARCHAR (128)     NOT NULL,
    [Source]                 NVARCHAR (1024)    NOT NULL,
    [SourceId]               UNIQUEIDENTIFIER   NOT NULL,
    [ExecutionId]            UNIQUEIDENTIFIER   NOT NULL,
    [EventBeg]               DATETIME2 (7)      NOT NULL,
    [EventEnd]               DATETIME2 (7)      NOT NULL,
    [DataCode]               INT                NOT NULL,
    [DataBytes]              IMAGE              NOT NULL,
    [Message]                NVARCHAR (2048)    NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApp]          NVARCHAR (128)     NOT NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_SsisLogDetail] PRIMARY KEY CLUSTERED ([SsisLogDetailId] ASC)
);


GO
PRINT N'Creating Table [verf].[ItemCount]...';


GO
CREATE TABLE [verf].[ItemCount] (
    [ItemCountId]            INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [ServerName]             NVARCHAR (128)     NOT NULL,
    [DatabaseName]           NVARCHAR (128)     NOT NULL,
    [SchemaName]             NVARCHAR (128)     NOT NULL,
    [TableName]              NVARCHAR (128)     NOT NULL,
    [DescriptionName]        NVARCHAR (128)     NOT NULL,
    [CheckDate]              DATETIME           NOT NULL,
    [Items]                  INT                NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApp]          NVARCHAR (128)     NOT NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ItemCount] PRIMARY KEY CLUSTERED ([ItemCountId] ASC),
    CONSTRAINT [UK_ItemCount] UNIQUE NONCLUSTERED ([ServerName] ASC, [DatabaseName] ASC, [SchemaName] ASC, [TableName] ASC, [CheckDate] ASC)
);


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInserted]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInsertedApplication]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInsertedApplication] DEFAULT (APP_NAME()) FOR [txInsertedApplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInsertedHost]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInsertedSid]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txRowReplication]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogEnd_txInserted]...';


GO
ALTER TABLE [track].[ApplicationLogEnd]
    ADD CONSTRAINT [DF_ApplicationLogEnd_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogEnd_txRowReplication]...';


GO
ALTER TABLE [track].[ApplicationLogEnd]
    ADD CONSTRAINT [DF_ApplicationLogEnd_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogErrors_txInserted]...';


GO
ALTER TABLE [track].[ApplicationLogErrors]
    ADD CONSTRAINT [DF_ApplicationLogErrors_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogErrors_txRowReplication]...';


GO
ALTER TABLE [track].[ApplicationLogErrors]
    ADD CONSTRAINT [DF_ApplicationLogErrors_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInserted]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedApplication]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInsertedApplication] DEFAULT (APP_NAME()) FOR [txInsertedApplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedHost]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedSid]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txRowReplication]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInserted]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedApplication]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedApplication] DEFAULT (APP_NAME()) FOR [txInsertedApplication];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedHost]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedProcedure]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) FOR [txInsertedProcedure];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedSid]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txRowReplication]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogEnd_txInserted]...';


GO
ALTER TABLE [track].[BatchLogEnd]
    ADD CONSTRAINT [DF_BatchLogEnd_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogEnd_txRowReplication]...';


GO
ALTER TABLE [track].[BatchLogEnd]
    ADD CONSTRAINT [DF_BatchLogEnd_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedApplication]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedApplication] DEFAULT (APP_NAME()) FOR [txInsertedApplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedHost]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedProcedure]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) FOR [txInsertedProcedure];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedSid]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogEnd_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogEnd]
    ADD CONSTRAINT [DF_ProcedureLogEnd_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogEnd_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogEnd]
    ADD CONSTRAINT [DF_ProcedureLogEnd_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogErrors_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogErrors]
    ADD CONSTRAINT [DF_ProcedureLogErrors_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogErrors_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogErrors]
    ADD CONSTRAINT [DF_ProcedureLogErrors_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogIntermediate_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate]
    ADD CONSTRAINT [DF_ProcedureLogIntermediate_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogIntermediate_txInsertedProcedure]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate]
    ADD CONSTRAINT [DF_ProcedureLogIntermediate_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) FOR [txInsertedProcedure];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogIntermediate_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate]
    ADD CONSTRAINT [DF_ProcedureLogIntermediate_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedApplication]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedApplication] DEFAULT (APP_NAME()) FOR [txInsertedApplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedHost]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedProcedure]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) FOR [txInsertedProcedure];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedSid]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInserted]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedApp]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedApp] DEFAULT (APP_NAME()) FOR [txInsertedApp];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedHost]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedSid]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txRowReplication]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [verf].[DF_ItemCount_txInserted]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [DF_ItemCount_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [verf].[DF_ItemCount_txInsertedApp]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [DF_ItemCount_txInsertedApp] DEFAULT (APP_NAME()) FOR [txInsertedApp];


GO
PRINT N'Creating Default Constraint [verf].[DF_ItemCount_txInsertedHost]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [DF_ItemCount_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [verf].[DF_ItemCount_txInsertedSid]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [DF_ItemCount_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [verf].[DF_ItemCount_txInsertedUserExecute]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [DF_ItemCount_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [verf].[DF_ItemCount_txInsertedUserOriginal]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [DF_ItemCount_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [verf].[DF_ItemCount_txRowReplication]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [DF_ItemCount_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Foreign Key [track].[FK_ApplicationLogEnd_Application]...';


GO
ALTER TABLE [track].[ApplicationLogEnd]
    ADD CONSTRAINT [FK_ApplicationLogEnd_Application] FOREIGN KEY ([ApplicationLogId]) REFERENCES [track].[ApplicationLogBegin] ([ApplicationLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ApplicationLogErrors_Application]...';


GO
ALTER TABLE [track].[ApplicationLogErrors]
    ADD CONSTRAINT [FK_ApplicationLogErrors_Application] FOREIGN KEY ([ApplicationLogId]) REFERENCES [track].[ApplicationLogBegin] ([ApplicationLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ApplicationLogOrphans_Application]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [FK_ApplicationLogOrphans_Application] FOREIGN KEY ([ApplicationLogId]) REFERENCES [track].[ApplicationLogBegin] ([ApplicationLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_BatchLogEnd_Batch]...';


GO
ALTER TABLE [track].[BatchLogEnd]
    ADD CONSTRAINT [FK_BatchLogEnd_Batch] FOREIGN KEY ([BatchLogId]) REFERENCES [track].[BatchLogBegin] ([BatchLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogEnd_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogEnd]
    ADD CONSTRAINT [FK_ProcedureLogEnd_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogErrors_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogErrors]
    ADD CONSTRAINT [FK_ProcedureLogErrors_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogIntermediate_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate]
    ADD CONSTRAINT [FK_ProcedureLogIntermediate_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogOrphans_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [FK_ProcedureLogOrphans_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Check Constraint [track].[CL_ApplicationLogErrors_ErrorMessage]...';


GO
ALTER TABLE [track].[ApplicationLogErrors]
    ADD CONSTRAINT [CL_ApplicationLogErrors_ErrorMessage] CHECK ([ErrorMessage] <> N'');


GO
PRINT N'Creating Check Constraint [track].[CL_ProcedureLogBegin_ObjectName]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [CL_ProcedureLogBegin_ObjectName] CHECK ([ObjectName] <> N'');


GO
PRINT N'Creating Check Constraint [track].[CL_ProcedureLogBegin_SchemaName]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [CL_ProcedureLogBegin_SchemaName] CHECK ([SchemaName] <> N'');


GO
PRINT N'Creating Check Constraint [track].[CL_ProcedureLogErrors_ErrorMessage]...';


GO
ALTER TABLE [track].[ProcedureLogErrors]
    ADD CONSTRAINT [CL_ProcedureLogErrors_ErrorMessage] CHECK ([ErrorMessage] <> N'');


GO
PRINT N'Creating Check Constraint [track].[CL_ProcedureLogErrors_ErrorProcedure]...';


GO
ALTER TABLE [track].[ProcedureLogErrors]
    ADD CONSTRAINT [CL_ProcedureLogErrors_ErrorProcedure] CHECK ([ErrorProcedure] <> N'');


GO
PRINT N'Creating Check Constraint [verf].[CL_ItemCount_DatabaseName]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [CL_ItemCount_DatabaseName] CHECK ([DatabaseName]	<> '');


GO
PRINT N'Creating Check Constraint [verf].[CL_ItemCount_DescriptionName]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [CL_ItemCount_DescriptionName] CHECK ([DescriptionName]	<> '');


GO
PRINT N'Creating Check Constraint [verf].[CL_ItemCount_SchemaName]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [CL_ItemCount_SchemaName] CHECK ([SchemaName]	<> '');


GO
PRINT N'Creating Check Constraint [verf].[CL_ItemCount_ServerName]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [CL_ItemCount_ServerName] CHECK ([ServerName]	<> '');


GO
PRINT N'Creating Check Constraint [verf].[CL_ItemCount_TableName]...';


GO
ALTER TABLE [verf].[ItemCount]
    ADD CONSTRAINT [CL_ItemCount_TableName] CHECK ([TableName]	<> '');


GO
PRINT N'Creating View [track].[SqlAgentHistorySteps]...';


GO
CREATE VIEW [track].[SqlAgentHistorySteps]
WITH VIEW_METADATA
AS
SELECT
		[instance_id]			= CHECKSUM(@@SERVERNAME),
		[job_instance_id]		= [t].[instance_id],

		[Instance]				= @@SERVERNAME,
		[InstanceHost]			= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]			= @@SERVICENAME,

	[t].[ServerName],
	[t].[JobName],
	[t].[StepId],
	[t].[StepName],
	[t].[StepMessage],
		[RunStatus]				= CASE [t].[run_status]
									WHEN 0	THEN 'Failed'
									WHEN 1	THEN 'Succeeded'
									WHEN 2	THEN 'Retry'
									WHEN 3	THEN 'Canceled'
									WHEN 4	THEN 'In Progress'
									ELSE		 'Unknown'
									END,

	[t].[RetryCount],

	[t].[JobBegin],
	[t].[JobBeginDate],
	[t].[JobBeginTime],

		[JobEnd]				= DATEADD(SECOND, [t].[DurationSeconds], [t].[JobBegin]),
		[JobEndDate]			= CONVERT(DATE, DATEADD(SECOND, [t].[DurationSeconds], [t].[JobBegin])),
		[JobEndTime]			= DATEADD(SECOND, [t].[DurationSeconds], [t].[JobBeginTime]),

		[DurationDays]			= [t].[DurationSeconds] / 86400.0,
		[DurationMinutes]		= [t].[DurationSeconds] / 60.0,
	[t].[DurationSeconds]
FROM (
	SELECT
		[t].[instance_id],
		[t].[run_status],

		[t].[ServerName],
		[t].[JobName],
		[t].[StepId],
		[t].[StepName],
		[t].[StepMessage],
		[t].[RetryCount],

			[JobBegin]			= CONVERT(DATETIME, [t].[JobBeginDate]) + CONVERT(DATETIME, [t].[JobBeginTime]),
		[t].[JobBeginDate],
		[t].[JobBeginTime],

			[DurationSeconds]	= CONVERT(INT, LEFT([t].[Duration], 2))				* 86400 +	--	Days
									CONVERT(INT, SUBSTRING([t].[Duration], 4, 2))	* 3600 +	--	Hours
									CONVERT(INT, SUBSTRING([t].[Duration], 7, 2))	* 60 +		--	Minutes
									CONVERT(INT, RIGHT([t].[Duration], 2))						--	Seconds
	FROM (
		SELECT
			[h].[instance_id],
			[h].[run_status],

				[ServerName]		= [v].[name],
				[JobName]			= [j].[name],
				[StepId]			= [h].[step_id],
				[StepName]			= [h].[step_name],
				[StepMessage]		= [h].[message],
				[RetryCount]		= [h].[retries_attempted],
				[JobBeginDate]		= CONVERT(DATE, CONVERT(CHAR(8), [h].[run_date]), 112),
				[JobBeginTime]		= CONVERT(TIME, STUFF(STUFF(RIGHT(REPLICATE('0', 6) + CONVERT(VARCHAR(6), [h].[run_time]), 6), 5, 0, ':'), 3, 0, ':'), 120),
				[Duration]			= STUFF(STUFF(STUFF(RIGHT(REPLICATE('0', 8) + CONVERT(VARCHAR(8), [h].[run_duration]), 8), 3, 0, ':'), 6, 0, ':'), 9, 0, ':')
		FROM
			[msdb].[dbo].[sysjobs]						[j]
		INNER JOIN
			[msdb].[sys].[servers]						[v]
				ON	([j].[originating_server_id]	=	[v].[server_id])
		INNER JOIN
			[msdb].[dbo].[sysjobhistory]				[h]
				ON	([j].[job_id]					=	[h].[job_id])
		WHERE
			([h].[step_id] <> 0)
		) [t]
	) [t];
GO
PRINT N'Creating View [track].[SqlAgentScheduleBase]...';


GO
CREATE VIEW [track].[SqlAgentScheduleBase]
WITH VIEW_METADATA
AS
SELECT
		[instance_id]			= CHECKSUM(@@SERVERNAME),

		[Instance]				= @@SERVERNAME,
		[InstanceHost]			= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]			= @@SERVICENAME,

	[t].[ServerName],
	[t].[JobName],
	[t].[JobEnabled],
	[t].[Category],
	[t].[CategoryClass],
	[t].[CategoryType],
	[t].[OwnerName],
	[t].[ScheduleName],
	[t].[ScheduleEnabled],
	[t].[FrequencyInterval],
	[t].[Frequency],
	[t].[SubFrequencyInterval],
	[t].[SubFrequency],

		[ActiveBegin]			= CONVERT(DATETIME, [t].[ActiveBeginDate]) + CONVERT(DATETIME, [t].[ActiveBeginTime]),
	[t].[ActiveBeginDate],
	[t].[ActiveBeginTime],

		[ActiveEnd]				= CONVERT(DATETIME, [t].[ActiveEndDate]) + CONVERT(DATETIME, [t].[ActiveEndTime]),
	[t].[ActiveEndDate],
	[t].[ActiveEndTime],

		[ScheduleSpanSeconds]	= DATEDIFF(SECOND, [t].[ActiveBeginTime], [t].[ActiveEndTime]),

		[NextRun]				= CONVERT(DATETIME, [t].[NextRunDate]) + CONVERT(DATETIME, [t].[NextRunTime]),
	[t].[NextRunDate],
	[t].[NextRunTime],

	[t].[ScheduleUid],
		[IntervalLimit]			=	CASE [t].[SubFrequency]
										WHEN 'Seconds'					THEN 86000.0
										WHEN 'Minutes'					THEN  1400.0
										WHEN 'Hours'					THEN    24.0
										WHEN 'At the specified time'	THEN	NULL
										ELSE 1.0
										END / CONVERT(FLOAT, [t].[SubFrequencyInterval])
FROM (
	SELECT
		[ServerName]			= [v].[name],
		[JobName]				= [j].[name],
		[JobEnabled]			= CASE [j].[enabled]
									WHEN 1 THEN 'Enabled'
									WHEN 0 THEN 'Disabled'
									ELSE		'Unknown'
									END,
		[Category]				= [c].[name],
		[CategoryClass]			= CASE [c].[category_class]
									WHEN 1 THEN 'Job'
									WHEN 2 THEN 'Alert'
									WHEN 3 THEN 'Operator'
									ELSE		'Unknown'
									END,
		[CategoryType]			= CASE [c].[category_type]
									WHEN 1 THEN 'Local'
									WHEN 2 THEN 'Multiserver'
									WHEN 3 THEN 'None'
									ELSE		'Unknown'
									END,
		[OwnerName]				= [p].[name],
		[ScheduleName]			= [s].[name],
		[ScheduleEnabled]		= CASE [s].[enabled]
									WHEN 1 THEN 'Enabled'
									WHEN 0 THEN 'Disabled'
									ELSE		'Unknown'
									END,
	
		[FrequencyInterval]		= [s].[freq_interval],
		[Frequency]				= CASE [s].[freq_type]
									WHEN   1	THEN 'One time only'
									WHEN   4	THEN 'Daily'
									WHEN   8	THEN 'Weekly'
									WHEN  16	THEN 'Monthly'
									WHEN  32	THEN 'Monthly, relative to freq_interval'
									WHEN  64	THEN 'SQL Server Agent service starts'
									WHEN 128	THEN 'Idle'
									ELSE			 'Unknown'
									END,

		[SubFrequencyInterval]	= [s].[freq_subday_interval],
		[SubFrequency]			= CASE [s].[freq_subday_type]
									WHEN 1 THEN 'At the specified time'
									WHEN 2 THEN 'Seconds'
									WHEN 4 THEN 'Minutes'
									WHEN 8 THEN 'Hours'
									ELSE		'Unknown'
									END,
		[ActiveBeginDate]		= CONVERT(DATE, RIGHT(REPLICATE('0', 8) + CONVERT(CHAR(8), [s].[active_start_date]), 8), 112),
		[ActiveBeginTime]		= CONVERT(TIME, STUFF(STUFF(RIGHT(REPLICATE('0', 6) + CONVERT(VARCHAR(6), [s].[active_start_time]),	6), 5, 0, ':'), 3, 0, ':'), 120),

		[ActiveEndDate]			= CASE WHEN ([s].[freq_subday_type] = 1)
									THEN NULL
									ELSE CONVERT(DATE, RIGHT(REPLICATE('0', 8) + CONVERT(CHAR(8), [s].[active_end_date]), 8), 112)
									END,
		[ActiveEndTime]			= CASE WHEN ([s].[freq_subday_type] = 1)
									THEN NULL
									ELSE CONVERT(TIME, STUFF(STUFF(RIGHT(REPLICATE('0', 6) + CONVERT(VARCHAR(6), [s].[active_end_time]), 6), 5, 0, ':'), 3, 0, ':'), 120)
									END,

		[NextRunDate]			= CASE WHEN ([z].[next_run_date] > 0) THEN
									CONVERT(DATE, RIGHT(REPLICATE('0', 8) + CONVERT(CHAR(8), [z].[next_run_date]), 8), 112)
									END,
		[NextRunTime]			= CONVERT(TIME, STUFF(STUFF(RIGHT(REPLICATE('0', 6) + CONVERT(VARCHAR(6), [z].[next_run_time]), 6), 5, 0, ':'), 3, 0, ':'), 120),

		[ScheduleUid]			= [s].[schedule_uid]
	FROM
		[msdb].[dbo].[sysjobs]						[j]
	LEFT OUTER JOIN
		[msdb].[sys].[servers]						[v]
			ON	([j].[originating_server_id]	=	[v].[server_id])
	LEFT OUTER JOIN
		[msdb].[dbo].[syscategories]				[c]
			ON	([j].[category_id]				=	[c].[category_id])
	LEFT OUTER JOIN
		[msdb].[sys].[database_principals]			[p]
			ON	([j].[owner_sid]				=	[p].[sid])
	LEFT OUTER JOIN
		[msdb].[dbo].[sysjobschedules]				[z]
			ON	([j].[job_id]					=	[z].[job_id])
	LEFT OUTER JOIN
		[msdb].[dbo].[sysschedules]					[s]
			ON	([z].[schedule_id]				=	[s].[schedule_id])
	) [t];
GO
PRINT N'Creating View [track].[SqlAgentSchedule]...';


GO
CREATE VIEW [track].[SqlAgentSchedule]
WITH VIEW_METADATA
AS
WITH [cte]
(
	[idx],
	[ScheduleUid],
	[SubFrequency],
	[SubFrequencyInterval],
	[PreviousStartTime],
	[IntermediateStartTime],
	[ActiveEndTime],
	[IntervalLimit]
)
AS
(
	SELECT ALL
			[idx]						= 1,
		[a].[ScheduleUid],
		[a].[SubFrequency],
		[a].[SubFrequencyInterval],
			[PreviousStartTime]			= [a].[ActiveBeginTime],
			[IntermediateStartTime]		= [a].[ActiveBeginTime],
		[a].[ActiveEndTime],
		[a].[IntervalLimit]
	FROM
		[track].[SqlAgentScheduleBase]	[a]

	UNION ALL

	SELECT ALL
		[t].[idx],
		[t].[ScheduleUid],
		[t].[SubFrequency],
		[t].[SubFrequencyInterval],
		[t].[PreviousStartTime],
		[t].[IntermediateStartTime],
		[t].[ActiveEndTime],
		[t].[IntervalLimit]
	FROM (
		SELECT ALL
				[idx]						= [c].[idx] + 1,
			[c].[ScheduleUid],
			[c].[SubFrequency],
			[c].[SubFrequencyInterval],
				[PreviousStartTime]			= [c].[IntermediateStartTime],
				[IntermediateStartTime]		= CASE [c].[SubFrequency]
												WHEN 'Seconds'	THEN DATEADD(SECOND, [c].[SubFrequencyInterval], [c].[IntermediateStartTime])
												WHEN 'Minutes'	THEN DATEADD(MINUTE, [c].[SubFrequencyInterval], [c].[IntermediateStartTime])
												WHEN 'Hours'	THEN DATEADD(HOUR,	 [c].[SubFrequencyInterval], [c].[IntermediateStartTime])
												END,
			[c].[ActiveEndTime],
			[c].[IntervalLimit]
		FROM
			[cte]			[c]
		WHERE
				([c].[IntervalLimit]			<=	100)
			AND	([c].[SubFrequencyInterval]		>	0)
			AND	([c].[IntermediateStartTime]	<	[c].[ActiveEndTime])
			AND	([c].[idx]						<=	100)
		) [t]
	WHERE
		([t].[IntermediateStartTime] >= [t].[PreviousStartTime])
)
SELECT
		[instance_id]			= CHECKSUM(@@SERVERNAME),

		[Instance]				= @@SERVERNAME,
		[InstanceHost]			= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]			= @@SERVICENAME,

	[t].[ServerName],
	[t].[JobName],
	[t].[JobEnabled],
	[t].[Category],
	[t].[CategoryClass],
	[t].[CategoryType],
	[t].[OwnerName],
	[t].[ScheduleName],
	[t].[ScheduleEnabled],
	[t].[FrequencyInterval],
	[t].[Frequency],
	[t].[SubFrequencyInterval],
	[t].[SubFrequency],

	[t].[ActiveBegin],
	[t].[ActiveBeginDate],
	[t].[ActiveBeginTime],

	[t].[ActiveEnd],
	[t].[ActiveEndDate],
	[t].[ActiveEndTime],

		[ScheduleSpanDays]			= [t].[ScheduleSpanSeconds] / 86400.0,
		[ScheduleSpanMinutes]		= [t].[ScheduleSpanSeconds] / 60.0,
	[t].[ScheduleSpanSeconds],

	[t].[NextRun],
	[t].[NextRunDate],
	[t].[NextRunTime],
	
	[c].[IntermediateStartTime]
FROM
	[track].[SqlAgentScheduleBase]	[t]
LEFT OUTER JOIN
	[cte]							[c]
		ON	([t].[ScheduleUid]	=	[c].[ScheduleUid]);
GO
PRINT N'Creating View [track].[SqlAgentHistory]...';


GO
CREATE VIEW [track].[SqlAgentHistory]
WITH VIEW_METADATA
AS
SELECT
		[instance_id]			= CHECKSUM(@@SERVERNAME),

		[Instance]				= @@SERVERNAME,
		[InstanceHost]			= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]			= @@SERVICENAME,

	[t].[ServerName],
	[t].[JobName],
	[t].[StepMessage],
		[RunStatus]				= CASE [t].[run_status]
									WHEN 0	THEN 'Failed'
									WHEN 1	THEN 'Succeeded'
									WHEN 2	THEN 'Retry'
									WHEN 3	THEN 'Canceled'
									WHEN 4	THEN 'In Progress'
									ELSE		 'Unknown'
									END,
	[t].[RetryCount],

	[t].[JobBegin],
	[t].[JobBeginDate],
	[t].[JobBeginTime],

		[JobEnd]				= DATEADD(SECOND, [t].[DurationSeconds], [t].[JobBegin]),
		[JobEndDate]			= CONVERT(DATE, DATEADD(SECOND, [t].[DurationSeconds], [t].[JobBegin])),
		[JobEndTime]			= DATEADD(SECOND, [t].[DurationSeconds], [t].[JobBeginTime]),

		[DurationDays]			= [t].[DurationSeconds] / 86400.0,
		[DurationMinutes]		= [t].[DurationSeconds] / 60.0,
	[t].[DurationSeconds]
FROM (
	SELECT
		[t].[ServerName],
		[t].[JobName],
		[t].[StepMessage],
		[t].[run_status],
		[t].[RetryCount],

			[JobBegin]			= CONVERT(DATETIME, [t].[JobBeginDate]) + CONVERT(DATETIME, [t].[JobBeginTime]),
		[t].[JobBeginDate],
		[t].[JobBeginTime],

			[DurationSeconds]	= CONVERT(INT, LEFT([t].[Duration], 2))				* 86400 +	--	Days
									CONVERT(INT, SUBSTRING([t].[Duration], 4, 2))	* 3600 +	--	Hours
									CONVERT(INT, SUBSTRING([t].[Duration], 7, 2))	* 60 +		--	Minutes
									CONVERT(INT, RIGHT([t].[Duration], 2))						--	Seconds
	FROM (
		SELECT
			[h].[run_status],

				[ServerName]		= [v].[name],
				[JobName]			= [j].[name],
				[StepMessage]		= [h].[message],
				[RetryCount]		= [h].[retries_attempted],
				[JobBeginDate]		= CONVERT(DATE, CONVERT(CHAR(8), [h].[run_date]), 112),
				[JobBeginTime]		= CONVERT(TIME, STUFF(STUFF(RIGHT(REPLICATE('0', 6) + CONVERT(VARCHAR(6), [h].[run_time]), 6), 5, 0, ':'), 3, 0, ':'), 120),
				[Duration]			= STUFF(STUFF(STUFF(RIGHT(REPLICATE('0', 8) + CONVERT(VARCHAR(8), [h].[run_duration]), 8), 3, 0, ':'), 6, 0, ':'), 9, 0, ':')
		FROM
			[msdb].[dbo].[sysjobs]						[j]
		INNER JOIN
			[msdb].[sys].[servers]						[v]
				ON	([j].[originating_server_id]	=	[v].[server_id])
		INNER JOIN
			[msdb].[dbo].[sysjobhistory]				[h]
				ON	([j].[job_id]					=	[h].[job_id])
		WHERE
			([h].[step_id] = 0)
		) [t]
	) [t];
GO
PRINT N'Creating View [track].[ApplicationLog]...';


GO
CREATE VIEW [track].[ApplicationLog]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
	[b].[ApplicationLogId],

		[database_id]				= DB_ID(),

		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[DatabaseName]				= DB_NAME(),

	[b].[ClassName],
	[b].[FunctionName],

	[b].[ApplicationVersion],
	[b].[ApplicationPlatform],

		[ApplicationUserOriginal]	= [b].[txInsertedUserOriginal],
		[ApplicationUserExecute]	= [b].[txInsertedUserExecute],
		[ApplicationHost]			= [b].[txInsertedHost],
		[ApplicationApplication]	= [b].[txInsertedApplication],

		[ApplicationBegin]			= CONVERT(DATETIME2,	[b].[txInserted]),
		[ApplicationBeginDate]		= CONVERT(DATE,			[b].[txInserted]),
		[ApplicationBeginTime]		= CONVERT(TIME,			[b].[txInserted]),
		[ApplicationBeginZone]		= [b].[txInserted],

		[ApplicationEnd]			= CONVERT(DATETIME2,	[e].[txInserted]),
		[ApplicationEndDate]		= CONVERT(DATE,			[e].[txInserted]),
		[ApplicationEndTime]		= CONVERT(TIME,			[e].[txInserted]),
		[ApplicationEndZone]		= [e].[txInserted],
		
		[ApplicationError]			= CONVERT(DATETIME2,	[r].[txInserted]),
		[ApplicationErrorDate]		= CONVERT(DATE,			[r].[txInserted]),
		[ApplicationErrorTime]		= CONVERT(TIME,			[r].[txInserted]),
		[ApplicationErrorZone]		= [r].[txInserted],
		
		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]), 114), 1, 2, 
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]))),

		[DurationDays]				= DATEDIFF(MINUTE, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted])) / 86400.0,
		[DurationMinutes]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted])) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted])),

	[r].[ErrorMessage]

FROM
	[track].[ApplicationLogBegin]		[b]
LEFT OUTER JOIN
	[track].[ApplicationLogEnd]			[e]
		ON	([b].[ApplicationLogId]	=	[e].[ApplicationLogId])
LEFT OUTER JOIN
	[track].[ApplicationLogErrors]		[r]
		ON	([b].[ApplicationLogId]	=	[r].[ApplicationLogId])
LEFT OUTER JOIN
	[track].[ApplicationLogOrphans]		[o]
		ON	([b].[ApplicationLogId]	=	[o].[ApplicationLogId]);
GO
PRINT N'Creating View [track].[BatchLog]...';


GO
CREATE VIEW [track].[BatchLog]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
	[b].[BatchLogId],

		[database_id]				= DB_ID(),

		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[DatabaseName]				= DB_NAME(),
	[b].[SchemaName],
	[b].[TableName],
	[b].[SourceData],

		[ApplicationUserOriginal]	= [b].[txInsertedUserOriginal],
		[ApplicationUserExecute]	= [b].[txInsertedUserExecute],
		[ApplicationHost]			= [b].[txInsertedHost],
		[ApplicationApplication]	= [b].[txInsertedApplication],

	[e].[RowCount],
	
		[UpdateBeg]					= CONVERT(DATETIME2,	[e].[UpdateBeg]),
		[UpdateBegDate]				= CONVERT(DATE,			[e].[UpdateBeg]),
		[UpdateBegTime]				= CONVERT(TIME,			[e].[UpdateBeg]),
		[UpdateBegZone]				= [e].[UpdateBeg],

		[UpdateEnd]					= CONVERT(DATETIME2,	[e].[UpdateEnd]),
		[UpdateEndDate]				= CONVERT(DATE,			[e].[UpdateEnd]),
		[UpdateEndTime]				= CONVERT(TIME,			[e].[UpdateEnd]),
		[UpdateEndZone]				= [e].[UpdateEnd],

	[e].[SourceNotes],

		[Duration]					= STUFF(CONVERT(VARCHAR(20),	CONVERT(DATETIME, [e].[txInserted])	- CONVERT(DATETIME, [b].[txInserted]), 114), 1, 2,
											DATEDIFF(HOUR, 0,		CONVERT(DATETIME, [e].[txInserted])	- CONVERT(DATETIME, [b].[txInserted]))),

		[DurationDays]				= DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted]) / 86400.0,
		[DurationMinutes]			= DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted]) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted])

FROM
	[track].[BatchLogBegin]			[b]
LEFT OUTER JOIN
	[track].[BatchLogEnd]			[e]
		ON	([b].[BatchLogId]	=	[e].[BatchLogId]);
GO
PRINT N'Creating View [track].[ProcedureLogInter]...';


GO
CREATE VIEW [track].[ProcedureLogInter]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
	[b].[ProcedureLogId],

		[database_id]				= DB_ID(),
	[b].[schema_id],
	[b].[object_id],

		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[DatabaseName]				= DB_NAME(),
	[b].[SchemaName],
	[b].[ObjectName],
	[b].[QualifiedName],

		[ProcedureSPID]				= [b].[SPID],
		[ProcedureNestLevel]		= [b].[NestLevel],
		[ProcedureTranCount]		= [b].[TransactionCount],

		[ApplicationUserOriginal]	= [b].[txInsertedUserOriginal],
		[ApplicationUserExecute]	= [b].[txInsertedUserExecute],
		[ProcedureHost]				= [b].[txInsertedHost],
		[ProcedureApplication]		= [b].[txInsertedApplication],

		[ProcedureBeg]				= [b].[txInserted],

		[SegmentEnd]				= [i].[txInserted],

		[DurationMinutes]			= DATEDIFF(SECOND,
										LAG([i].[txInserted], 1, [b].[txInserted]) OVER(PARTITION BY [b].[ProcedureLogId] ORDER BY [i].[txInserted], [i].[ProcedureLogIntermediateId]),
										[i].[txInserted]
										) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND,
										LAG([i].[txInserted], 1, [b].[txInserted]) OVER(PARTITION BY [b].[ProcedureLogId] ORDER BY [i].[txInserted], [i].[ProcedureLogIntermediateId]),
										[i].[txInserted]
										),

	[i].[ProcedureLineNumber],
	[i].[ProcedureMessage]

FROM
	[track].[ProcedureLogBegin]			[b]
LEFT OUTER JOIN
	[track].[ProcedureLogIntermediate]	[i]
		ON	([b].[ProcedureLogId]	=	[i].[ProcedureLogId]);
GO
PRINT N'Creating View [track].[SsisLogPackage]...';


GO
CREATE VIEW [track].[SsisLogPackage]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
		[Instance]			= @@SERVERNAME,
		[InstanceHost]		= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]		= @@SERVICENAME,

		[Package]			= [t].[txInsertedApp],
		[PackageName]		= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN LEFT([t].[txInsertedApp], CHARINDEX(' (', [t].[txInsertedApp]) - 1)
								ELSE [t].[txInsertedApp]
								END,
		[PackageVersion]	= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN REPLACE(RIGHT([t].[txInsertedApp], LEN([t].[txInsertedApp]) - CHARINDEX(' (', [t].[txInsertedApp]) - 1), ')', '')
								ELSE CONVERT(VARCHAR, NULL)
								END,

		[PackageBeg]		= MIN([t].[EventBeg]),
		[PackageBegDate]	= CONVERT(DATE,			MIN([t].[EventBeg])),
		[PackageBegTime]	= CONVERT(TIME,			MIN([t].[EventBeg])),

		[PackageEnd]		= MAX([t].[EventEnd]),
		[PackageEndDate]	= CONVERT(DATE,			MAX([t].[EventEnd])),
		[PackageEndTime]	= CONVERT(TIME,			MAX([t].[EventEnd])),

		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])), 114), 1, 2,
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])))),

		[DurationDays]		= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventEnd])) / 86400.0,
		[DurationMinutes]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventEnd])) / 60.0,
		[DurationSeconds]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventEnd])),

		[Errors]			= COUNT(CASE WHEN ([t].[Event]	= 'OnError')		THEN 1 END),
		[Warnings]			= COUNT(CASE WHEN ([t].[Event]	= 'OnWarning')		THEN 1 END),
		[Information]		= COUNT(CASE WHEN ([t].[Event]	= 'OnInformation')	THEN 1 END),
		[TasksFailed]		= COUNT(CASE WHEN ([t].[Event]	= 'OnTaskFailed')	THEN 1 END),

		[PackageSources]	= COUNT(DISTINCT [t].[SourceId]),
		[PackageEvents]		= COUNT(*),

	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],

	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp]
FROM
	[track].[SsisLogDetail]	[t]
GROUP BY
	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],
	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp];
GO
PRINT N'Creating View [track].[SsisLogSource]...';


GO
CREATE VIEW [track].[SsisLogSource]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
		[Instance]			= @@SERVERNAME,
		[InstanceHost]		= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]		= @@SERVICENAME,

		[LogDetailId]		= MIN([SsisLogDetailId]),

		[Package]			= [t].[txInsertedApp],
		[PackageName]		= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN LEFT([t].[txInsertedApp], CHARINDEX(' (', [t].[txInsertedApp]) - 1)
								ELSE [t].[txInsertedApp]
								END,
		[PackageVersion]	= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN REPLACE(RIGHT([t].[txInsertedApp], LEN([t].[txInsertedApp]) - CHARINDEX(' (', [t].[txInsertedApp]) - 1), ')', '')
								ELSE CONVERT(VARCHAR, NULL)
								END,

		[SourceName]		= [t].[Source],

		[SourceBeg]			= MIN([t].[EventBeg]),
		[SourceBegDate]		= CONVERT(DATE,	MIN([t].[EventBeg])),
		[SourceBegTime]		= CONVERT(TIME, MIN([t].[EventBeg])),

		[SourceEnd]			= MAX([t].[EventEnd]),
		[SourceEndDate]		= CONVERT(DATE, MAX([t].[EventEnd])),
		[SourceEndTime]		= CONVERT(TIME, MAX([t].[EventEnd])),

		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])), 114), 1, 2,
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])))),

		[DurationDays]		= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventBeg])) / 86400.0,
		[DurationMinutes]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventBeg])) / 60.0,
		[DurationSeconds]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventBeg])),

		[Errors]			= COUNT(CASE WHEN ([t].[Event]	= 'OnError')		THEN 1 END),
		[Warnings]			= COUNT(CASE WHEN ([t].[Event]	= 'OnWarning')		THEN 1 END),
		[Information]		= COUNT(CASE WHEN ([t].[Event]	= 'OnInformation')	THEN 1 END),
		[TasksFailed]		= COUNT(CASE WHEN ([t].[Event]	= 'OnTaskFailed')	THEN 1 END),

		[SourceEvents]		= COUNT(*),

	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],

	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp]
FROM
	[track].[SsisLogDetail]	[t]
GROUP BY
	[t].[Source],
	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],
	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp];
GO
PRINT N'Creating Function [track].[BatchSize]...';


GO
CREATE FUNCTION [track].[BatchSize]
(
	@ObjectId			INT,
	@MemoryThreshold	FLOAT	= 0.85,
	@TargetRatio		FLOAT	= 1.0
)
RETURNS BIGINT
WITH RETURNS NULL ON NULL INPUT
AS
BEGIN

	DECLARE	@BatchSize	BIGINT;

	DECLARE	@RowCount	BIGINT;
	DECLARE	@Ratio		FLOAT;

	SELECT
		@RowCount	= MAX([p].[rows]),
		@Ratio		= ROUND(
						((@TargetRatio * [s].[committed_target_kb]) + ((1.0 - @TargetRatio) * [s].[committed_kb])) / 8.0 /
						SUM([a].[total_pages])
						, 3)
	FROM
		sys.sql_expression_dependencies		[d]
	INNER JOIN
		sys.objects							[r]
			ON	([d].[referencing_id]	=	[r].[object_id])
			AND	([r].[type]				=	'P')
	INNER JOIN
		sys.objects							[o]
			ON	([d].[referenced_id]	=	[o].[object_id])
			AND	([o].[is_ms_shipped]	=	0)
	INNER JOIN
		sys.indexes							[i]
			ON	([o].[object_id]		=	[i].[object_id])
			AND	([i].[is_primary_key]	=	1)
	INNER JOIN
		sys.partitions						[p]
			ON	([i].[object_id]		=	[p].[object_id])
			AND	([i].[index_id]			=	[p].[index_id])
	INNER JOIN
		sys.allocation_units				[a]
			ON	([p].[partition_id]		=	[a].[container_id])
	CROSS JOIN
		sys.dm_os_sys_info					[s]
	WHERE
			([d].[referencing_id]	=	@ObjectId)
		AND	NOT (
				([o].[name]			= LEFT([r].[name], LEN([o].[name])))
			AND	([o].[schema_id]	= [r].[schema_id])
			)
	GROUP BY
		[s].[committed_kb],
		[s].[committed_target_kb];

	SET	@BatchSize = CEILING(@Rowcount * 
			CASE WHEN ((@Ratio - 1.0) > (1.0 - @MemoryThreshold))
			THEN	1.0
			ELSE	CASE WHEN (@Ratio < @MemoryThreshold)
						THEN @Ratio
						ELSE @MemoryThreshold
						END
			END)

	RETURN	@BatchSize;

END;
GO
PRINT N'Creating Function [track].[StringOccuranceCount]...';


GO
CREATE FUNCTION [track].[StringOccuranceCount]
(
	@SearchTerm		NVARCHAR(MAX),
	@SearchString	NVARCHAR(MAX)
)
RETURNS INT
WITH SCHEMABINDING, RETURNS NULL ON NULL INPUT
AS
BEGIN

	RETURN (DATALENGTH(@SearchString) - DATALENGTH(REPLACE(@SearchString, @SearchTerm, N''))) / NULLIF(DATALENGTH(@SearchTerm), 0);

END;
GO
PRINT N'Creating Function [track].[ProcedureAttributes]...';


GO
CREATE FUNCTION [track].[ProcedureAttributes]
(
	@ExecuteThreshold	INT	=	3
)
RETURNS TABLE
AS
RETURN
(
	SELECT
		[t].[object_id],

		[t].[SchemaName],
		[t].[ObjectName],
			[QualifiedName]	= QUOTENAME([t].[SchemaName]) + N'.' + QUOTENAME([t].[ObjectName]),

			[IsWrapper]		= CONVERT(BIT, CASE WHEN ([track].[StringOccuranceCount]('EXEC', [t].[SqlDef]) > @ExecuteThreshold)
								THEN 1
								ELSE 0
								END),

			[IsDelete]		= CONVERT(BIT, CASE WHEN ([t].[SqlDef] LIKE '%DELETE%FROM%')
								THEN 1
								ELSE 0
								END)
	FROM (
		SELECT
			[p].[object_id],
				[SchemaName]	= [s].[name],
				[ObjectName]	= [p].[name],
				[SqlDef]		= OBJECT_DEFINITION([p].[object_id])
		FROM
			sys.schemas						[s]
		INNER JOIN
			sys.procedures					[p]
				ON	([s].[schema_id]	=	[p].[schema_id])
		) [t]
);
GO
PRINT N'Creating View [track].[ProcedureLog]...';


GO
CREATE VIEW [track].[ProcedureLog]
WITH VIEW_METADATA
AS
SELECT
	[b].[ProcedureLogId],

		[database_id]				= DB_ID(),
	[b].[schema_id],
	[b].[object_id],

		[ServerName]				= @@SERVERNAME,
		[DatabaseName]				= DB_NAME(),
	[b].[SchemaName],
	[b].[ObjectName],
	[b].[QualifiedName],

	[b].[SPID],
	[b].[NestLevel],
	[b].[TransactionCount],

		[ProcedureUserOriginal]		= [b].[txInsertedUserOriginal],
		[ProcedureUserExecute]		= [b].[txInsertedUserExecute],
		[ProcedureHost]				= [b].[txInsertedHost],
		[ProcedureApplication]		= [b].[txInsertedApplication],

		[ProcedureStatus]			= CASE
										WHEN ([e].[txInserted]	IS NOT NULL)	THEN 'Succeeded'
										WHEN ([r].[txInserted]	IS NOT NULL)	THEN 'Failed'
										WHEN ([o].[txInserted]	IS NOT NULL)	THEN 'Ended Unexpectedly'
										ELSE 'Running'
										END,

		[ProcedureBegin]			= CONVERT(DATETIME2,	[b].[txInserted]),
		[ProcedureBeginDate]		= CONVERT(DATE,			[b].[txInserted]),
		[ProcedureBeginTime]		= CONVERT(TIME,			[b].[txInserted]),
		[ProcedureBeginZone]		= [b].[txInserted],

		[ProcedureEnd]				= CONVERT(DATETIME2,	[e].[txInserted]),
		[ProcedureEndDate]			= CONVERT(DATE,			[e].[txInserted]),
		[ProcedureEndTime]			= CONVERT(TIME,			[e].[txInserted]),
		[ProcedureEndZone]			= [e].[txInserted],

		[ProcedureError]			= CONVERT(DATETIME2,	[r].[txInserted]),
		[ProcedureErrorDate]		= CONVERT(DATE,			[r].[txInserted]),
		[ProcedureErrorTime]		= CONVERT(TIME,			[r].[txInserted]),
		[ProcedureErrorZone]		= [r].[txInserted],

		[ProcedureOrphaned]			= CONVERT(DATETIME2,	[o].[txInserted]),
		[ProcedureOrphanedDate]		= CONVERT(DATE,			[o].[txInserted]),
		[ProcedureOrphanedTime]		= CONVERT(TIME,			[o].[txInserted]),
		[ProcedureOrphanedZone]		= [o].[txInserted],

		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]), 114), 1, 2,
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]))),

		[DurationDays]				= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted], IIF([o].[txInserted] IS NULL, SYSDATETIMEOFFSET(), NULL))) / 86400.0,
		[DurationMinutes]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted], IIF([o].[txInserted] IS NULL, SYSDATETIMEOFFSET(), NULL))) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted], IIF([o].[txInserted] IS NULL, SYSDATETIMEOFFSET(), NULL))),

	[r].[ErrorNumber],
	[r].[ErrorSeverity],
	[r].[ErrorState],
	[r].[ErrorProcedure],
	[r].[ErrorLine],
	[r].[ErrorMessage],

		[IsWrapper]					= CONVERT(BIT, COALESCE([a].[IsWrapper], 0)),
		[IsDelete]					= CONVERT(BIT, COALESCE([a].[IsDelete], 0))

FROM
	[track].[ProcedureLogBegin]			[b]
LEFT OUTER JOIN
	[track].[ProcedureLogEnd]			[e]
		ON	([b].[ProcedureLogId]	=	[e].[ProcedureLogId])
LEFT OUTER JOIN
	[track].[ProcedureLogErrors]		[r]
		ON	([b].[ProcedureLogId]	=	[r].[ProcedureLogId])
LEFT OUTER JOIN
	[track].[ProcedureLogOrphans]		[o]
		ON	([b].[ProcedureLogId]	=	[o].[ProcedureLogId])
LEFT OUTER JOIN
	[track].[ProcedureAttributes](3)	[a]
		ON	([b].[object_id]		=	[a].[object_id]);
GO
PRINT N'Creating Procedure [dbo].[sp_ssis_addlogentry]...';


GO
CREATE PROCEDURE [dbo].[sp_ssis_addlogentry]
(
	@event			SYSNAME,
	@computer		NVARCHAR(128),
	@operator		NVARCHAR(128),
	@source			NVARCHAR(1024),
	@sourceid		UNIQUEIDENTIFIER,
	@executionid	UNIQUEIDENTIFIER,
	@starttime		DATETIME2,
	@endtime		DATETIME2,
	@datacode		INT,
	@databytes		IMAGE,
	@message		NVARCHAR(2048)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 1000;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[SsisLogDetail]
		(
			[Event],
			[Computer],
			[Operator],
			[Source],
			[SourceId],
			[ExecutionId],
			[EventBeg],
			[EventEnd],
			[DataCode],
			[DataBytes],
			[Message]
		)
		VALUES
		(
			@event,
			@computer,
			@operator,
			@source,
			@sourceid,
			@executionid,
			@starttime,
			@endtime,
			@datacode,
			@databytes,
			@message
		);

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Select_ProcedureLog]...';


GO
CREATE PROCEDURE [track].[Select_ProcedureLog]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		DROP TABLE IF EXISTS #ReturnTable_ProcedureLog;

		CREATE TABLE #ReturnTable_ProcedureLog
		(
			[ReturnTableId]					INT					NOT	NULL	IDENTITY(1, 1) NOT FOR REPLICATION,

			[ProcedureLogId]				INT					NOT	NULL,

			[database_id]					SMALLINT			NOT	NULL,
			[schema_id]						INT					NOT	NULL,
			[object_id]						INT					NOT	NULL,

			[ServerName]					NVARCHAR(128)		NOT	NULL,
			[DatabaseName]					NVARCHAR(128)		NOT	NULL,
			[SchemaName]					NVARCHAR(128)		NOT	NULL,
			[ObjectName]					NVARCHAR(128)		NOT	NULL,
			[QualifiedName]					NVARCHAR(261)		NOT	NULL,

			[SPID]							SMALLINT			NOT	NULL,
			[NestLevel]						INT					NOT	NULL,
			[TransactionCount]				INT					NOT	NULL,

			[ProcedureUserOriginal]			NVARCHAR(128)		NOT	NULL,
			[ProcedureUserExecute]			NVARCHAR(128)		NOT	NULL,
			[ProcedureHost]					NVARCHAR(128)		NOT	NULL,
			[ProcedureApplication]			NVARCHAR(128)		NOT	NULL,

			[ProcedureStatus]				VARCHAR(24)			NOT	NULL,

			[ProcedureBegin]				DATETIME2			NOT	NULL,
			[ProcedureBeginDate]			DATE				NOT	NULL,
			[ProcedureBeginTime]			TIME				NOT	NULL,
			[ProcedureBeginZone]			DATETIMEOFFSET(7)	NOT	NULL,

			[ProcedureEnd]					DATETIME2				NULL,
			[ProcedureEndDate]				DATE					NULL,
			[ProcedureEndTime]				TIME					NULL,
			[ProcedureEndZone]				DATETIMEOFFSET(7)		NULL,

			[ProcedureError]				DATETIME2				NULL,
			[ProcedureErrorDate]			DATE					NULL,
			[ProcedureErrorTime]			TIME					NULL,
			[ProcedureErrorZone]			DATETIMEOFFSET(7)		NULL,

			[ProcedureOrphaned]				DATETIME2				NULL,
			[ProcedureOrphanedDate]			DATE					NULL,
			[ProcedureOrphanedTime]			TIME					NULL,
			[ProcedureOrphanedZone]			DATETIMEOFFSET(7)		NULL,

			[Duration]						VARCHAR(20)				NULL,

			[DurationDays]					FLOAT					NULL,
			[DurationMinutes]				FLOAT					NULL,
			[DurationSeconds]				FLOAT					NULL,

			[ErrorNumber]					INT						NULL,
			[ErrorSeverity]					INT						NULL,
			[ErrorState]					INT						NULL,
			[ErrorProcedure]				NVARCHAR(128)			NULL,
			[ErrorLine]						INT						NULL,
			[ErrorMessage]					NVARCHAR(MAX)			NULL,

			[IsWrapper]						BIT						NULL,
			[IsDelete]						BIT						NULL,

			PRIMARY KEY CLUSTERED([ReturnTableId]	ASC)
		);

		DECLARE	@SqlBase		NVARCHAR(MAX)	= N'
		IF (OBJECT_ID(''[$(DatabaseName)].[track].[ProcedureLog]'') IS NOT NULL)
		BEGIN

			INSERT INTO #ReturnTable_ProcedureLog	WITH(TABLOCK)
			(
				[ProcedureLogId],

				[database_id],
				[schema_id],
				[object_id],

				[ServerName],
				[DatabaseName],
				[SchemaName],
				[ObjectName],
				[QualifiedName],

				[SPID],
				[NestLevel],
				[TransactionCount],

				[ProcedureUserOriginal],
				[ProcedureUserExecute],
				[ProcedureHost],
				[ProcedureApplication],

				[ProcedureStatus],

				[ProcedureBegin],
				[ProcedureBeginDate],
				[ProcedureBeginTime],
				[ProcedureBeginZone],

				[ProcedureEnd],
				[ProcedureEndDate],
				[ProcedureEndTime],
				[ProcedureEndZone],

				[ProcedureError],
				[ProcedureErrorDate],
				[ProcedureErrorTime],
				[ProcedureErrorZone],

				[ProcedureOrphaned],
				[ProcedureOrphanedDate],
				[ProcedureOrphanedTime],
				[ProcedureOrphanedZone],

				[Duration],

				[DurationDays],
				[DurationMinutes],
				[DurationSeconds],

				[ErrorNumber],
				[ErrorSeverity],
				[ErrorState],
				[ErrorProcedure],
				[ErrorLine],
				[ErrorMessage],

				[IsWrapper],
				[IsDelete]
			)
			SELECT
				[t].[ProcedureLogId],

				[t].[database_id],
				[t].[schema_id],
				[t].[object_id],

				[t].[ServerName],
				[t].[DatabaseName],
				[t].[SchemaName],
				[t].[ObjectName],
				[t].[QualifiedName],

				[t].[SPID],
				[t].[NestLevel],
				[t].[TransactionCount],

				[t].[ProcedureUserOriginal],
				[t].[ProcedureUserExecute],
				[t].[ProcedureHost],
				[t].[ProcedureApplication],

				[t].[ProcedureStatus],

				[t].[ProcedureBegin],
				[t].[ProcedureBeginDate],
				[t].[ProcedureBeginTime],
				[t].[ProcedureBeginZone],

				[t].[ProcedureEnd],
				[t].[ProcedureEndDate],
				[t].[ProcedureEndTime],
				[t].[ProcedureEndZone],

				[t].[ProcedureError],
				[t].[ProcedureErrorDate],
				[t].[ProcedureErrorTime],
				[t].[ProcedureErrorZone],

				[t].[ProcedureOrphaned],
				[t].[ProcedureOrphanedDate],
				[t].[ProcedureOrphanedTime],
				[t].[ProcedureOrphanedZone],

				[t].[Duration],

				[t].[DurationDays],
				[t].[DurationMinutes],
				[t].[DurationSeconds],

				[t].[ErrorNumber],
				[t].[ErrorSeverity],
				[t].[ErrorState],
				[t].[ErrorProcedure],
				[t].[ErrorLine],
				[t].[ErrorMessage],

				[t].[IsWrapper],
				[t].[IsDelete]
			FROM
				[$(DatabaseName)].[track].[ProcedureLog]	[t];

		END;';

		DECLARE @DbName			NVARCHAR(128)	= N'';
		DECLARE @SqlCommand		NVARCHAR(MAX);

		WHILE (@DbName IS NOT NULL)
		BEGIN

			SELECT
				@DbName = MIN([d].[name])
			FROM
				sys.databases	[d]
			WHERE
					([d].[database_id] > 4)
				AND	([d].[name] NOT IN (N'master', N'model', N'msdb', N'tempdb', N'DWConfiguration', N'DWDiagnostics', N'DWQueue', N'SSISDB', N'SSRS', N'SSRSTempDB'))
				AND	([d].[name]	> @DbName);

			SET @SqlCommand = REPLACE(@SqlBase, N'$(DatabaseName)', @DbName);

			PRINT CONVERT(NCHAR(23), SYSDATETIME(), 121) + NCHAR(9) + N'Querying database [' + @DbName + N']';

			EXECUTE sp_executesql @SqlCommand;

		END;

		SELECT
			[t].[ProcedureLogId],

			[t].[database_id],
			[t].[schema_id],
			[t].[object_id],

			[t].[ServerName],
			[t].[DatabaseName],
			[t].[SchemaName],
			[t].[ObjectName],
			[t].[QualifiedName],

			[t].[SPID],
			[t].[NestLevel],
			[t].[TransactionCount],

			[t].[ProcedureUserOriginal],
			[t].[ProcedureUserExecute],
			[t].[ProcedureHost],
			[t].[ProcedureApplication],

			[t].[ProcedureStatus],

			[t].[ProcedureBegin],
			[t].[ProcedureBeginDate],
			[t].[ProcedureBeginTime],
			[t].[ProcedureBeginZone],

			[t].[ProcedureEnd],
			[t].[ProcedureEndDate],
			[t].[ProcedureEndTime],
			[t].[ProcedureEndZone],

			[t].[ProcedureError],
			[t].[ProcedureErrorDate],
			[t].[ProcedureErrorTime],
			[t].[ProcedureErrorZone],

			[t].[ProcedureOrphaned],
			[t].[ProcedureOrphanedDate],
			[t].[ProcedureOrphanedTime],
			[t].[ProcedureOrphanedZone],

			[t].[Duration],

			[t].[DurationDays],
			[t].[DurationMinutes],
			[t].[DurationSeconds],

			[t].[ErrorNumber],
			[t].[ErrorSeverity],
			[t].[ErrorState],
			[t].[ErrorProcedure],
			[t].[ErrorLine],
			[t].[ErrorMessage],

			[t].[IsWrapper],
			[t].[IsDelete]
		FROM
			#ReturnTable_ProcedureLog	[t] WITH (NOLOCK);

		DROP TABLE IF EXISTS #ReturnTable_ProcedureLog;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Select_BatchLog]...';


GO
CREATE PROCEDURE [track].[Select_BatchLog]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		DROP TABLE IF EXISTS #ReturnTable_BatchLog;

		CREATE TABLE #ReturnTable_BatchLog
		(
			[ReturnTableId]					INT					NOT	NULL	IDENTITY(1, 1)	NOT FOR REPLICATION,
			[BatchLogId]					INT					NOT	NULL,

			[DatabaseId]					SMALLINT			NOT	NULL,

			[DatabaseName]					NVARCHAR(128)		NOT	NULL,
			[SchemaName]					NVARCHAR(128)		NOT	NULL,
			[TableName]						NVARCHAR(128)		NOT	NULL,
			[SourceData]					NVARCHAR(128)		NOT	NULL,

			[ApplicationUserOriginal]		NVARCHAR(128)		NOT	NULL,
			[ApplicationUserExecute]		NVARCHAR(128)		NOT	NULL,
			[ApplicationHost]				NVARCHAR(128)		NOT	NULL,
			[ApplicationApp]				NVARCHAR(128)		NOT	NULL,

			[RowCount]						INT						NULL,
			[UpdateDateBeg]					DATETIMEOFFSET(7)		NULL,
			[UpdateDateEnd]					DATETIMEOFFSET(7)		NULL,
			[SourceNotes]					VARCHAR(MAX)			NULL,

			[Duration]						VARCHAR(20)				NULL,

			[DurationDays]					FLOAT					NULL,
			[DurationMinutes]				FLOAT					NULL,
			[DurationSeconds]				FLOAT					NULL,

			CONSTRAINT	[PK_#ReturnTable_BatchLog]	PRIMARY KEY CLUSTERED([ReturnTableId]	ASC)
		);

		DECLARE	@SqlBase		VARCHAR(MAX)	= N'
		IF (OBJECT_ID(''[$(DatabaseName)].[track].[BatchLog]'') IS NOT NULL)
		BEGIN

			INSERT INTO #ReturnTable_BatchLog	WITH(TABLOCK)
			(
				[BatchLogId],

				[DatabaseId],

				[DatabaseName],
				[SchemaName],
				[TableName],
				[SourceData],

				[ApplicationUserOriginal],
				[ApplicationUserExecute],
				[ApplicationHost],
				[ApplicationApp],

				[RowCount],
				[UpdateDateBeg],
				[UpdateDateEnd],
				[SourceNotes],

				[Duration],

				[DurationDays],
				[DurationMinutes],
				[DurationSeconds]
			)
			SELECT
				[t].[BatchLogId],

				[t].[DatabaseId],

				[t].[DatabaseName],
				[t].[SchemaName],
				[t].[TableName],
				[t].[SourceData],

				[t].[ApplicationUserOriginal],
				[t].[ApplicationUserExecute],
				[t].[ApplicationHost],
				[t].[ApplicationApp],

				[t].[RowCount],
				[t].[UpdateDateBeg],
				[t].[UpdateDateEnd],
				[t].[SourceNotes],

				[t].[Duration],

				[t].[DurationDays],
				[t].[DurationMinutes],
				[t].[DurationSeconds]
			FROM
				[$(DatabaseName)].[track].[BatchLog]	[t];

		END;';

		DECLARE @DbName			NVARCHAR(128)	= N'';
		DECLARE @SqlCommand		NVARCHAR(MAX);

		WHILE (@DbName IS NOT NULL)
		BEGIN

			SELECT
				@DbName = MIN([d].[name])
			FROM
				sys.databases	[d]
			WHERE
					([d].[database_id] > 4)
				AND	([d].[name] NOT IN (N'master', N'model', N'msdb', N'tempdb', N'DWConfiguration', N'DWDiagnostics', N'DWQueue', N'SSISDB', N'SSRS', N'SSRSTempDB'))
				AND	([d].[name]	> @DbName);

			SET @SqlCommand = REPLACE(@SqlBase, N'$(DatabaseName)', @DbName);

			PRINT CONVERT(NCHAR(23), SYSDATETIME(), 121) + NCHAR(9) + N'Querying database [' + @DbName + N']';

			EXECUTE sp_executesql @SqlCommand;

		END;

		SELECT
			[t].[ReturnTableId],
			[t].[BatchLogId],

			[t].[DatabaseId],
			[t].[DatabaseName],
			[t].[SchemaName],
			[t].[TableName],
			[t].[SourceData],

			[t].[ApplicationUserOriginal],
			[t].[ApplicationUserExecute],
			[t].[ApplicationHost],
			[t].[ApplicationApp],

			[t].[RowCount],

				[TimezoneOffsetHours]	= DATEPART(TZ, [t].[UpdateDateBeg]) / 60.0,

				[UpdateDateBeg]			= CONVERT(DATETIME2, [t].[UpdateDateBeg]),
				[UpdateDateEnd]			= CONVERT(DATETIME2, [t].[UpdateDateEnd]),

			[t].[SourceNotes],

			[t].[Duration],

			[t].[DurationDays],
			[t].[DurationMinutes],
			[t].[DurationSeconds]
		FROM
			#ReturnTable_BatchLog	[t];

		DROP TABLE IF EXISTS #ReturnTable_BatchLog;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Select_ApplicationLog]...';


GO
CREATE PROCEDURE [track].[Select_ApplicationLog]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		DROP TABLE IF EXISTS #ReturnTable_ApplicationLog;

		CREATE TABLE #ReturnTable_ApplicationLog
		(
			[ReturnTableId]					INT					NOT	NULL	IDENTITY(1, 1)	NOT FOR REPLICATION,
			[ApplicationLogId]				INT					NOT	NULL,

			[DatabaseId]					SMALLINT			NOT	NULL,
			[DatabaseName]					NVARCHAR(128)		NOT	NULL,

			[ClassName]						VARCHAR(128)		NOT	NULL,
			[FunctionName]					VARCHAR(128)		NOT	NULL,

			[ApplicationVersion]			VARCHAR(128)		NOT	NULL,
			[ApplicationPlatform]			VARCHAR(128)		NOT	NULL,

			[ApplicationUserOriginal]		NVARCHAR(128)		NOT	NULL,
			[ApplicationUserExecute]		NVARCHAR(128)		NOT	NULL,
			[ApplicationHost]				NVARCHAR(128)		NOT	NULL,
			[ApplicationApp]				NVARCHAR(128)		NOT	NULL,

			[ApplicationBegin]				DATETIMEOFFSET(7)	NOT	NULL,
			[ApplicationEnd]				DATETIMEOFFSET(7)		NULL,
			[ApplicationError]				DATETIMEOFFSET(7)		NULL,
			[ApplicationTerminate]			DATETIMEOFFSET(7)		NULL,

			[Duration]						VARCHAR(20)				NULL,

			[DurationDays]					FLOAT					NULL,
			[DurationMinutes]				FLOAT					NULL,
			[DurationSeconds]				FLOAT					NULL,

			[ErrorMessage]					NVARCHAR(MAX)			NULL,

			CONSTRAINT	[PK_#ReturnTable_ApplicationLog]	PRIMARY KEY CLUSTERED([ReturnTableId]	ASC)
		);

		DECLARE	@SqlBase		NVARCHAR(MAX)	= N'
		IF (OBJECT_ID(''[$(DatabaseName)].[track].[ApplicationLog]'') IS NOT NULL)
		BEGIN

			INSERT INTO #ReturnTable_ApplicationLog	WITH(TABLOCK)
			(
				[ApplicationLogId],

				[DatabaseId],
				[DatabaseName],

				[ClassName],
				[FunctionName],

				[ApplicationVersion],
				[ApplicationPlatform],

				[ApplicationUserOriginal],
				[ApplicationUserExecute],
				[ApplicationHost],
				[ApplicationApp],

				[ApplicationBegin],
				[ApplicationEnd],
				[ApplicationError],
				[ApplicationTerminate],

				[Duration],

				[DurationDays],
				[DurationMinutes],
				[DurationSeconds],

				[ErrorMessage]
			)
			SELECT
				[t].[ApplicationLogId],

				[t].[DatabaseId],
				[t].[DatabaseName],

				[t].[ClassName],
				[t].[FunctionName],

				[t].[ApplicationVersion],
				[t].[ApplicationPlatform],

				[t].[ApplicationUserOriginal],
				[t].[ApplicationUserExecute],
				[t].[ApplicationHost],
				[t].[ApplicationApp],

				[t].[ApplicationBegin],
				[t].[ApplicationEnd],
				[t].[ApplicationError],
				[t].[ApplicationTerminate],

				[t].[Duration],

				[t].[DurationDays],
				[t].[DurationMinutes],
				[t].[DurationSeconds],

				[t].[ErrorMessage]
			FROM
				[$(DatabaseName)].[track].[ApplicationLog]	[t];

		END;';

		DECLARE @DbName			NVARCHAR(128)	= N'';
		DECLARE @SqlCommand		NVARCHAR(MAX);

		WHILE (@DbName IS NOT NULL)
		BEGIN

			SELECT
				@DbName = MIN([d].[name])
			FROM
				sys.databases	[d]
			WHERE
					([d].[database_id] > 4)
				AND	([d].[name] NOT IN (N'master', N'model', N'msdb', N'tempdb', N'DWConfiguration', N'DWDiagnostics', N'DWQueue', N'SSISDB', N'SSRS', N'SSRSTempDB'))
				AND	([d].[name]	> @DbName);

			SET @SqlCommand = REPLACE(@SqlBase, N'$(DatabaseName)', @DbName);

			PRINT CONVERT(NCHAR(23), SYSDATETIME(), 121) + NCHAR(9) + N'Querying database [' + @DbName + N']';

			EXECUTE sp_executesql @SqlCommand;

		END;

		SELECT
			[t].[ReturnTableId],
			[t].[ApplicationLogId],

			[t].[DatabaseId],
			[t].[DatabaseName],

			[t].[ClassName],
			[t].[FunctionName],

			[t].[ApplicationVersion],
			[t].[ApplicationPlatform],

			[t].[ApplicationUserOriginal],
			[t].[ApplicationUserExecute],
			[t].[ApplicationHost],
			[t].[ApplicationApp],

				[TimezoneOffsetHours]	= DATEPART(TZ, [t].[ApplicationBegin]) / 60.0,

				[ApplicationBegin]		= CONVERT(DATETIME2, [t].[ApplicationBegin]),
				[ApplicationEnd]		= CONVERT(DATETIME2, [t].[ApplicationEnd]),
				[ApplicationError]		= CONVERT(DATETIME2, [t].[ApplicationError]),
				[ApplicationTerminate]	= CONVERT(DATETIME2, [t].[ApplicationTerminate]),

			[t].[Duration],

			[t].[DurationDays],
			[t].[DurationMinutes],
			[t].[DurationSeconds],

			[t].[ErrorMessage]
		FROM
			#ReturnTable_ApplicationLog	[t];

		DROP TABLE IF EXISTS #ReturnTable_ApplicationLog;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Delete_ProcedureLog]...';


GO
CREATE PROCEDURE [track].[Delete_ProcedureLog]
(
	@proc_id				INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @TxnId			NUMERIC(18, 0)	= NULL;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

	DELETE FROM	[track].[ProcedureLogOrphans]	WHERE (1=0);
	DELETE FROM	[track].[ProcedureLogErrors]	WHERE (1=0);
	DELETE FROM	[track].[ProcedureLogEnd]		WHERE (1=0);
	DELETE FROM	[track].[ProcedureLogBegin]		WHERE (1=0);

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

	END CATCH;

	RETURN @TxnId;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogBegin]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogBegin]
(
	@ApplicationName		NVARCHAR(128),
	@ClassName				VARCHAR(128),
	@FunctionName			VARCHAR(128),
	@ApplicationVersion		VARCHAR(128),
	@ApplicationPlatform	VARCHAR(128)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @TxnId			NUMERIC(18, 0)	= NULL;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogBegin]
		(
			[txInsertedApplication],
			[ClassName],
			[FunctionName],
			[ApplicationVersion],
			[ApplicationPlatform]
		)
		SELECT
			[txInsertedApplication]	= @ApplicationName,
			[ClassName]				= @ClassName,
			[FunctionName]			= @FunctionName,
			[ApplicationVersion]	= @ApplicationVersion,
			[ApplicationPlatform]	= @ApplicationPlatform;

		SET	@TxnId	= SCOPE_IDENTITY();

	---------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

	END CATCH;

	SELECT [TxnId] = @TxnId;
	RETURN @TxnId;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogEnd]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogEnd]
(
	@ApplicationLogId		INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogEnd]
		(
			[ApplicationLogId]
		)
		SELECT
			[ApplicationLogId] = @ApplicationLogId;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogError]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogError]
(
	@ApplicationLogId	INT,
	@ErrorMessage		VARCHAR(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogErrors]
		(
			[ApplicationLogId],
			[ErrorMessage]
		)
		SELECT
			[ApplicationLogId]	= @ApplicationLogId,
			[ErrorMessage]		= RTRIM(LTRIM(LEFT(@ErrorMessage, 4096)));

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_BatchLogBegin]...';


GO
CREATE PROCEDURE [track].[Insert_BatchLogBegin]
(
	@SchemaName		NVARCHAR(128),
	@TableName		NVARCHAR(128),
	@SourceData		NVARCHAR(128)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @TxnId			NUMERIC(18, 0)	= NULL;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[BatchLogBegin]
		(
			[SchemaName],
			[TableName],
			[SourceData]
		)
		SELECT
			[SchemaName]	= @SchemaName,
			[TableName]		= @TableName,
			[SourceData]	= @SourceData;

		SET	@TxnId	= SCOPE_IDENTITY();

	---------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

	END CATCH;

	SELECT [TxnId] = @TxnId;
	RETURN @TxnId;

END;
GO
PRINT N'Creating Procedure [track].[Insert_BatchLogEnd]...';


GO
CREATE PROCEDURE [track].[Insert_BatchLogEnd]
(
	@BatchLogId			INT,
	@RowCount			INT,
	@UpdateBeg			DATETIMEOFFSET(7),
	@UpdateEnd			DATETIMEOFFSET(7),
	@SourceNotes		VARCHAR(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[BatchLogEnd]
		(
			[BatchLogId],
			[RowCount],
			[UpdateBeg],
			[UpdateEnd],
			[SourceNotes]
		)
		SELECT
			[BatchLogId]		= @BatchLogId,
			[RowCount]			= @RowCount,
			[UpdateBeg]			= @UpdateBeg,
			[UpdateEnd]			= @UpdateEnd,
			[SourceNotes]		= @SourceNotes;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogBegin]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogBegin]
(
	@proc_id				INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @TxnId			NUMERIC(18, 0)	= NULL;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		PRINT CONVERT(NCHAR(23), SYSDATETIME(), 121) + NCHAR(9) + QUOTENAME(OBJECT_SCHEMA_NAME(@proc_id)) + N'.' + QUOTENAME(OBJECT_NAME(@proc_id));

		INSERT INTO [track].[ProcedureLogBegin]
		(
			[schema_id],
			[object_id],
			[SchemaName],
			[ObjectName],
			[SPID],
			[NestLevel],
			[TransactionCount]
		)
		SELECT
			[schema_id]			= SCHEMA_ID(OBJECT_SCHEMA_NAME(@proc_id)),
			[object_id]			= @proc_id,
			[SchemaName]		= OBJECT_SCHEMA_NAME(@proc_id),
			[ObjectName]		= OBJECT_NAME(@proc_id),
			[SPID]				= @@SPID,
			[NestLevel]			= @@NESTLEVEL - 1,
			[TransactionCount]	= @@TRANCOUNT - 1;

		SET	@TxnId	= SCOPE_IDENTITY();

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

	END CATCH;

	RETURN @TxnId;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogEnd]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogEnd]
(
	@ProcedureLogId		INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ProcedureLogEnd]
		(
			[ProcedureLogId]
		)
		SELECT
			[ProcedureLogId] = @ProcedureLogId;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogError]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogError]
(
	@ProcedureLogId		INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ProcedureLogErrors]
		(
			[ProcedureLogId],
			[ErrorNumber],
			[ErrorSeverity],
			[ErrorState],
			[ErrorProcedure],
			[ErrorLine],
			[ErrorMessage]
		)
		SELECT
			[ProcedureLogId]	= @ProcedureLogId,
			[ErrorNumber]		= ERROR_NUMBER(),
			[ErrorSeverity]		= ERROR_SEVERITY(),
			[ErrorState]		= ERROR_STATE(),
			[ErrorProcedure]	= COALESCE(ERROR_PROCEDURE(), 'Dynamic SQL'),
			[ErrorLine]			= ERROR_LINE(),
			[ErrorMessage]		= ERROR_MESSAGE();

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogIntermediate]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogIntermediate]
(
	@ObjectId				INT,
	@ProcedureLogId			INT,
	@ProcedureLineId		INT,
	@ProcedureMessage		VARCHAR(256)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	BEGIN TRY
	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	-----------------------------------------------------------------------------------------------

		PRINT CONVERT(NCHAR(23), SYSDATETIME(), 121) + NCHAR(9) + QUOTENAME(OBJECT_SCHEMA_NAME(@ObjectId)) + N'.' + QUOTENAME(OBJECT_NAME(@ObjectId)) + NCHAR(9) + CONVERT(NVARCHAR, @ProcedureLineId) + NCHAR(9) + @ProcedureMessage;

		INSERT INTO [track].[ProcedureLogIntermediate]
		(
			[ProcedureLogId],
			[ProcedureLineNumber],
			[ProcedureMessage]
		)
		SELECT
			[ProcedureLogId]	= @ProcedureLogId,
			[ProcedureLineId]	= @ProcedureLineId,
			[ProcedureMessage]	= @ProcedureMessage;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogOrphan]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogOrphan]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ProcedureLogOrphans]
		(
			[ProcedureLogId]
		)
		SELECT
			[b].[ProcedureLogId]
		FROM
			[track].[ProcedureLogBegin]			[b]	WITH (NOLOCK)
		LEFT OUTER JOIN
			[track].[ProcedureLogEnd]			[e]	WITH (NOLOCK)
				ON	([b].[ProcedureLogId]	=	[e].[ProcedureLogId])
		LEFT OUTER JOIN
			[track].[ProcedureLogErrors]		[r]	WITH (NOLOCK)
				ON	([b].[ProcedureLogId]	=	[r].[ProcedureLogId])
		LEFT OUTER JOIN
			[track].[ProcedureLogOrphans]		[o]	WITH (NOLOCK)
				ON	([b].[ProcedureLogId]	=	[o].[ProcedureLogId])
		WHERE
				([e].[ProcedureLogId]	IS NULL)
			AND	([r].[ProcedureLogId]	IS NULL)
			AND	([o].[ProcedureLogId]	IS NULL)
			AND	([b].[txInserted]		<	GETDATE());

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [verf].[InsertItemCount]...';


GO
CREATE PROCEDURE [verf].[InsertItemCount]
(
	@CheckDate		DATETIME	= NULL
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		SET	@CheckDate	= COALESCE(@CheckDate, SYSDATETIME());

		INSERT INTO [verf].[ItemCount]
		(
			[ServerName],
			[DatabaseName],
			[SchemaName],
			[TableName],
			[DescriptionName],
			[CheckDate],
			[Items]
		)
		SELECT
			[ServerName]		= @@SERVERNAME,
			[DatabaseName]		= DB_NAME(),
			[SchemaName]		= 'stg',
			[TableName]			= 'sample',
			[DescriptionName]	= 'sample table insert',
			[CheckDate]			= @CheckDate,
			[Items]				= 1;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[ProcProcedureLogOrphan]...';


GO
CREATE PROCEDURE [track].[ProcProcedureLogOrphan]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

--	Body goes here

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[ExampleProcedure]...';


GO
CREATE PROCEDURE [track].[ExampleProcedure]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		DROP TABLE IF EXISTS #TempTable;

		SELECT DB_NAME();

		DECLARE @RandomWait	VARCHAR(8) = CONVERT(VARCHAR(8), DATEADD(SECOND, RAND() * 60 * 10, 0), 108);
		PRINT @RandomWait

		WAITFOR DELAY @RandomWait;

		WAITFOR DELAY '00:00:05';

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogOrphan]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogOrphan]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogOrphans]
		(
			[ApplicationLogId]
		)
		SELECT
			[b].[ApplicationLogId]
		FROM
			[track].[ApplicationLogBegin]		[b]	WITH (NOLOCK)
		LEFT OUTER JOIN
			[track].[ApplicationLogEnd]			[e]	WITH (NOLOCK)
				ON	([b].[ApplicationLogId]	=	[e].[ApplicationLogId])
		LEFT OUTER JOIN
			[track].[ApplicationLogErrors]		[r]	WITH (NOLOCK)
				ON	([b].[ApplicationLogId]	=	[r].[ApplicationLogId])
		LEFT OUTER JOIN
			[track].[ApplicationLogOrphans]		[o]	WITH (NOLOCK)
				ON	([b].[ApplicationLogId]	=	[o].[ApplicationLogId])
		WHERE
				([e].[ApplicationLogId]	IS NULL)
			AND	([r].[ApplicationLogId]	IS NULL)
			AND	([o].[ApplicationLogId]	IS NULL)
			AND	([b].[txInserted]		<	GETDATE());

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Extended Property [dbo].[sp_ssis_addlogentry].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'SSIS SQL Logging Procedure', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'PROCEDURE', @level1name = N'sp_ssis_addlogentry';


GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET MULTI_USER 
    WITH ROLLBACK IMMEDIATE;


GO
PRINT N'Update complete.';


GO
