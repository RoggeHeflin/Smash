/*
Deployment script for Smash

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "Smash"
:setvar DefaultFilePrefix "Smash"
:setvar DefaultDataPath "D:\Data SQL Server\Data\"
:setvar DefaultLogPath "D:\Data SQL Server\Log\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
The column [track].[ApplicationLogBegin].[txInsertedApp] is being dropped, data loss could occur.

The column [track].[ApplicationLogBegin].[txInsertedServer] is being dropped, data loss could occur.
*/

IF EXISTS (select top 1 1 from [track].[ApplicationLogBegin])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [track].[ApplicationLogOrphans].[txInsertedApp] is being dropped, data loss could occur.
*/

IF EXISTS (select top 1 1 from [track].[ApplicationLogOrphans])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [track].[BatchLogBegin].[txInsertedApp] is being dropped, data loss could occur.

The column [track].[BatchLogBegin].[txInsertedServer] is being dropped, data loss could occur.
*/

IF EXISTS (select top 1 1 from [track].[BatchLogBegin])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [track].[BatchLogEnd].[UpdateDateBeg] is being dropped, data loss could occur.

The column [track].[BatchLogEnd].[UpdateDateEnd] is being dropped, data loss could occur.

The column [track].[BatchLogEnd].[UpdateBeg] on table [track].[BatchLogEnd] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

IF EXISTS (select top 1 1 from [track].[BatchLogEnd])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [track].[ProcedureLogBegin].[ObjectId] is being dropped, data loss could occur.

The column [track].[ProcedureLogBegin].[SchemaId] is being dropped, data loss could occur.

The column [track].[ProcedureLogBegin].[txInsertedApp] is being dropped, data loss could occur.

The column [track].[ProcedureLogBegin].[object_id] on table [track].[ProcedureLogBegin] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.

The column [track].[ProcedureLogBegin].[schema_id] on table [track].[ProcedureLogBegin] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

IF EXISTS (select top 1 1 from [track].[ProcedureLogBegin])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [track].[ProcedureLogOrphans].[txInsertedApp] is being dropped, data loss could occur.
*/

IF EXISTS (select top 1 1 from [track].[ProcedureLogOrphans])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogBegin_txInserted]...';


GO
ALTER TABLE [track].[ApplicationLogBegin] DROP CONSTRAINT [DF_ApplicationLogBegin_txInserted];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogBegin_txInsertedSid]...';


GO
ALTER TABLE [track].[ApplicationLogBegin] DROP CONSTRAINT [DF_ApplicationLogBegin_txInsertedSid];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogBegin_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ApplicationLogBegin] DROP CONSTRAINT [DF_ApplicationLogBegin_txInsertedUserOriginal];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogBegin_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ApplicationLogBegin] DROP CONSTRAINT [DF_ApplicationLogBegin_txInsertedUserExecute];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogBegin_txInsertedHost]...';


GO
ALTER TABLE [track].[ApplicationLogBegin] DROP CONSTRAINT [DF_ApplicationLogBegin_txInsertedHost];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogBegin_txInsertedApp]...';


GO
ALTER TABLE [track].[ApplicationLogBegin] DROP CONSTRAINT [DF_ApplicationLogBegin_txInsertedApp];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogBegin_txRowReplication]...';


GO
ALTER TABLE [track].[ApplicationLogBegin] DROP CONSTRAINT [DF_ApplicationLogBegin_txRowReplication];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogBegin_txInsertedServer]...';


GO
ALTER TABLE [track].[ApplicationLogBegin] DROP CONSTRAINT [DF_ApplicationLogBegin_txInsertedServer];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogOrphans_txInserted]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans] DROP CONSTRAINT [DF_ApplicationLogOrphans_txInserted];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedSid]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans] DROP CONSTRAINT [DF_ApplicationLogOrphans_txInsertedSid];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans] DROP CONSTRAINT [DF_ApplicationLogOrphans_txInsertedUserOriginal];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans] DROP CONSTRAINT [DF_ApplicationLogOrphans_txInsertedUserExecute];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedHost]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans] DROP CONSTRAINT [DF_ApplicationLogOrphans_txInsertedHost];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedApp]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans] DROP CONSTRAINT [DF_ApplicationLogOrphans_txInsertedApp];


GO
PRINT N'Dropping Default Constraint [track].[DF_ApplicationLogOrphans_txRowReplication]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans] DROP CONSTRAINT [DF_ApplicationLogOrphans_txRowReplication];


GO
PRINT N'Dropping Default Constraint [track].[DF_BatchLogBegin_txInserted]...';


GO
ALTER TABLE [track].[BatchLogBegin] DROP CONSTRAINT [DF_BatchLogBegin_txInserted];


GO
PRINT N'Dropping Default Constraint [track].[DF_BatchLogBegin_txInsertedSid]...';


GO
ALTER TABLE [track].[BatchLogBegin] DROP CONSTRAINT [DF_BatchLogBegin_txInsertedSid];


GO
PRINT N'Dropping Default Constraint [track].[DF_BatchLogBegin_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[BatchLogBegin] DROP CONSTRAINT [DF_BatchLogBegin_txInsertedUserOriginal];


GO
PRINT N'Dropping Default Constraint [track].[DF_BatchLogBegin_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[BatchLogBegin] DROP CONSTRAINT [DF_BatchLogBegin_txInsertedUserExecute];


GO
PRINT N'Dropping Default Constraint [track].[DF_BatchLogBegin_txInsertedHost]...';


GO
ALTER TABLE [track].[BatchLogBegin] DROP CONSTRAINT [DF_BatchLogBegin_txInsertedHost];


GO
PRINT N'Dropping Default Constraint [track].[DF_BatchLogBegin_txInsertedApp]...';


GO
ALTER TABLE [track].[BatchLogBegin] DROP CONSTRAINT [DF_BatchLogBegin_txInsertedApp];


GO
PRINT N'Dropping Default Constraint [track].[DF_BatchLogBegin_txInsertedServer]...';


GO
ALTER TABLE [track].[BatchLogBegin] DROP CONSTRAINT [DF_BatchLogBegin_txInsertedServer];


GO
PRINT N'Dropping Default Constraint [track].[DF_BatchLogBegin_txRowReplication]...';


GO
ALTER TABLE [track].[BatchLogBegin] DROP CONSTRAINT [DF_BatchLogBegin_txRowReplication];


GO
PRINT N'Dropping Default Constraint [track].[DF_BatchLogEnd_txInserted]...';


GO
ALTER TABLE [track].[BatchLogEnd] DROP CONSTRAINT [DF_BatchLogEnd_txInserted];


GO
PRINT N'Dropping Default Constraint [track].[DF_BatchLogEnd_txRowReplication]...';


GO
ALTER TABLE [track].[BatchLogEnd] DROP CONSTRAINT [DF_BatchLogEnd_txRowReplication];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogBegin_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] DROP CONSTRAINT [DF_ProcedureLogBegin_txInserted];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogBegin_txInsertedSid]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] DROP CONSTRAINT [DF_ProcedureLogBegin_txInsertedSid];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogBegin_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] DROP CONSTRAINT [DF_ProcedureLogBegin_txInsertedUserOriginal];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogBegin_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] DROP CONSTRAINT [DF_ProcedureLogBegin_txInsertedUserExecute];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogBegin_txInsertedHost]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] DROP CONSTRAINT [DF_ProcedureLogBegin_txInsertedHost];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogBegin_txInsertedApp]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] DROP CONSTRAINT [DF_ProcedureLogBegin_txInsertedApp];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogBegin_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] DROP CONSTRAINT [DF_ProcedureLogBegin_txRowReplication];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogIntermediate_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate] DROP CONSTRAINT [DF_ProcedureLogIntermediate_txRowReplication];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogIntermediate_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate] DROP CONSTRAINT [DF_ProcedureLogIntermediate_txInserted];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogOrphans_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans] DROP CONSTRAINT [DF_ProcedureLogOrphans_txInserted];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedSid]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans] DROP CONSTRAINT [DF_ProcedureLogOrphans_txInsertedSid];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans] DROP CONSTRAINT [DF_ProcedureLogOrphans_txInsertedUserOriginal];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans] DROP CONSTRAINT [DF_ProcedureLogOrphans_txInsertedUserExecute];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedHost]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans] DROP CONSTRAINT [DF_ProcedureLogOrphans_txInsertedHost];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedApp]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans] DROP CONSTRAINT [DF_ProcedureLogOrphans_txInsertedApp];


GO
PRINT N'Dropping Default Constraint [track].[DF_ProcedureLogOrphans_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans] DROP CONSTRAINT [DF_ProcedureLogOrphans_txRowReplication];


GO
PRINT N'Dropping Foreign Key [track].[FK_ApplicationLogErrors_Application]...';


GO
ALTER TABLE [track].[ApplicationLogErrors] DROP CONSTRAINT [FK_ApplicationLogErrors_Application];


GO
PRINT N'Dropping Foreign Key [track].[FK_ApplicationLogEnd_Application]...';


GO
ALTER TABLE [track].[ApplicationLogEnd] DROP CONSTRAINT [FK_ApplicationLogEnd_Application];


GO
PRINT N'Dropping Foreign Key [track].[FK_ApplicationLogOrphans_Application]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans] DROP CONSTRAINT [FK_ApplicationLogOrphans_Application];


GO
PRINT N'Dropping Foreign Key [track].[FK_BatchLogEnd_Batch]...';


GO
ALTER TABLE [track].[BatchLogEnd] DROP CONSTRAINT [FK_BatchLogEnd_Batch];


GO
PRINT N'Dropping Foreign Key [track].[FK_ProcedureLogOrphans_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans] DROP CONSTRAINT [FK_ProcedureLogOrphans_Procedure];


GO
PRINT N'Dropping Foreign Key [track].[FK_ProcedureLogIntermediate_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate] DROP CONSTRAINT [FK_ProcedureLogIntermediate_Procedure];


GO
PRINT N'Dropping Foreign Key [track].[FK_ProcedureLogErrors_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogErrors] DROP CONSTRAINT [FK_ProcedureLogErrors_Procedure];


GO
PRINT N'Dropping Foreign Key [track].[FK_ProcedureLogEnd_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogEnd] DROP CONSTRAINT [FK_ProcedureLogEnd_Procedure];


GO
PRINT N'Dropping Check Constraint [track].[CL_ProcedureLogBegin_NameObject]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] DROP CONSTRAINT [CL_ProcedureLogBegin_NameObject];


GO
PRINT N'Dropping Check Constraint [track].[CL_ProcedureLogBegin_NameSchema]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] DROP CONSTRAINT [CL_ProcedureLogBegin_NameSchema];


GO
PRINT N'Removing schema binding from [track].[ApplicationLog]...';


GO
ALTER VIEW [track].[ApplicationLog]
WITH VIEW_METADATA
AS
SELECT [b].[ApplicationLogId],
       DB_ID() AS [DatabaseId],
       DB_NAME() AS [DatabaseName],
       [b].[ClassName],
       [b].[FunctionName],
       [b].[ApplicationVersion],
       [b].[ApplicationPlatform],
       [b].[txInsertedUserOriginal] AS [ApplicationUserOriginal],
       [b].[txInsertedUserExecute] AS [ApplicationUserExecute],
       [b].[txInsertedHost] AS [ApplicationHost],
       [b].[txInsertedApp] AS [ApplicationApp],
       [b].[txInserted] AS [ApplicationBegin],
       [e].[txInserted] AS [ApplicationEnd],
       [r].[txInserted] AS [ApplicationError],
       COALESCE ([e].[txInserted], [r].[txInserted]) AS [ApplicationTerminate],
       STUFF(CONVERT (VARCHAR (20), CONVERT (DATETIME, COALESCE ([e].[txInserted], [r].[txInserted])) - CONVERT (DATETIME, [b].[txInserted]), 114), 1, 2, DATEDIFF(HOUR, 0, CONVERT (DATETIME, COALESCE ([e].[txInserted], [r].[txInserted])) - CONVERT (DATETIME, [b].[txInserted]))) AS [Duration],
       DATEDIFF(MINUTE, [b].[txInserted], COALESCE ([e].[txInserted], [r].[txInserted])) / 60.0 / 60.0 / 24.0 AS [DurationDays],
       DATEDIFF(SECOND, [b].[txInserted], COALESCE ([e].[txInserted], [r].[txInserted])) / 60.0 AS [DurationMinutes],
       DATEDIFF(SECOND, [b].[txInserted], COALESCE ([e].[txInserted], [r].[txInserted])) AS [DurationSeconds],
       [r].[ErrorMessage]
FROM   [track].[ApplicationLogBegin] AS [b] WITH (NOLOCK)
       LEFT OUTER JOIN
       [track].[ApplicationLogEnd] AS [e] WITH (NOLOCK)
       ON ([b].[ApplicationLogId] = [e].[ApplicationLogId])
       LEFT OUTER JOIN
       [track].[ApplicationLogErrors] AS [r] WITH (NOLOCK)
       ON ([b].[ApplicationLogId] = [r].[ApplicationLogId])
       LEFT OUTER JOIN
       [track].[ApplicationLogOrphans] AS [o] WITH (NOLOCK)
       ON ([b].[ApplicationLogId] = [o].[ApplicationLogId]);


GO
PRINT N'Removing schema binding from [track].[BatchLog]...';


GO
ALTER VIEW [track].[BatchLog]
WITH VIEW_METADATA
AS
SELECT [b].[BatchLogId],
       DB_ID() AS [DatabaseId],
       DB_NAME() AS [DatabaseName],
       [b].[SchemaName],
       [b].[TableName],
       [b].[SourceData],
       [b].[txInsertedUserOriginal] AS [ApplicationUserOriginal],
       [b].[txInsertedUserExecute] AS [ApplicationUserExecute],
       [b].[txInsertedHost] AS [ApplicationHost],
       [b].[txInsertedApp] AS [ApplicationApp],
       [e].[RowCount],
       [e].[UpdateDateBeg],
       [e].[UpdateDateEnd],
       [e].[SourceNotes],
       STUFF(CONVERT (VARCHAR (20), CONVERT (DATETIME, [e].[txInserted]) - CONVERT (DATETIME, [b].[txInserted]), 114), 1, 2, DATEDIFF(HOUR, 0, CONVERT (DATETIME, [e].[txInserted]) - CONVERT (DATETIME, [b].[txInserted]))) AS [Duration],
       DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted]) / 60.0 / 60.0 / 24.0 AS [DurationDays],
       DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted]) / 60.0 AS [DurationMinutes],
       DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted]) AS [DurationSeconds]
FROM   [track].[BatchLogBegin] AS [b] WITH (NOLOCK)
       LEFT OUTER JOIN
       [track].[BatchLogEnd] AS [e] WITH (NOLOCK)
       ON ([b].[BatchLogId] = [e].[BatchLogId]);


GO
PRINT N'Removing schema binding from [track].[ProcedureLogInter]...';


GO
ALTER VIEW [track].[ProcedureLogInter]
WITH VIEW_METADATA
AS
SELECT [b].[ProcedureLogId],
       DB_ID() AS [DatabaseId],
       [b].[ObjectId],
       DB_NAME() AS [DatabaseName],
       [b].[SchemaName],
       [b].[ObjectName],
       [b].[QualifiedName],
       [b].[SPID] AS [ProcedureSPID],
       [b].[NestLevel] AS [ProcedureNestLevel],
       [b].[TransactionCount] AS [ProcedureTranCount],
       [b].[txInsertedUserOriginal] AS [ApplicationUserOriginal],
       [b].[txInsertedUserExecute] AS [ApplicationUserExecute],
       [b].[txInsertedHost] AS [ProcedureHost],
       [b].[txInsertedApp] AS [ProcedureApp],
       [b].[txInserted] AS [ProcedureBegin],
       [i].[txInserted] AS [SegmentEnd],
       DATEDIFF(MINUTE, LAG([i].[txInserted], 1, [b].[txInserted]) OVER (PARTITION BY [b].[ProcedureLogId] ORDER BY [i].[txInserted], [i].[ProcedureLogIntermediateId]), [i].[txInserted]) AS [DurationMinutes],
       DATEDIFF(SECOND, LAG([i].[txInserted], 1, [b].[txInserted]) OVER (PARTITION BY [b].[ProcedureLogId] ORDER BY [i].[txInserted], [i].[ProcedureLogIntermediateId]), [i].[txInserted]) AS [DurationSeconds],
       [i].[ProcedureLineNumber],
       [i].[ProcedureMessage]
FROM   [track].[ProcedureLogBegin] AS [b] WITH (NOLOCK)
       LEFT OUTER JOIN
       [track].[ProcedureLogIntermediate] AS [i] WITH (NOLOCK)
       ON ([b].[ProcedureLogId] = [i].[ProcedureLogId]);


GO
PRINT N'Starting rebuilding table [track].[ApplicationLogBegin]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [track].[tmp_ms_xx_ApplicationLogBegin] (
    [ApplicationLogId]       INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [ClassName]              VARCHAR (128)      NOT NULL,
    [FunctionName]           VARCHAR (128)      NOT NULL,
    [ApplicationVersion]     VARCHAR (128)      NOT NULL,
    [ApplicationPlatform]    VARCHAR (128)      NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) CONSTRAINT [DF_ApplicationLogBegin_txInserted] DEFAULT (SYSDATETIMEOFFSET()) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     CONSTRAINT [DF_ApplicationLogBegin_txInsertedSid] DEFAULT (SUSER_SID()) NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     CONSTRAINT [DF_ApplicationLogBegin_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     CONSTRAINT [DF_ApplicationLogBegin_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     CONSTRAINT [DF_ApplicationLogBegin_txInsertedHost] DEFAULT (HOST_NAME()) NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     CONSTRAINT [DF_ApplicationLogBegin_txInsertedApplication] DEFAULT (APP_NAME()) NOT NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   CONSTRAINT [DF_ApplicationLogBegin_txRowReplication] DEFAULT (NEWSEQUENTIALID()) ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_ApplicationLogBegin1] PRIMARY KEY CLUSTERED ([ApplicationLogId] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [track].[ApplicationLogBegin])
    BEGIN
        SET IDENTITY_INSERT [track].[tmp_ms_xx_ApplicationLogBegin] ON;
        INSERT INTO [track].[tmp_ms_xx_ApplicationLogBegin] ([ApplicationLogId], [ClassName], [FunctionName], [ApplicationVersion], [ApplicationPlatform], [txInserted], [txInsertedSid], [txInsertedUserOriginal], [txInsertedUserExecute], [txInsertedHost], [txRowReplication])
        SELECT   [ApplicationLogId],
                 [ClassName],
                 [FunctionName],
                 [ApplicationVersion],
                 [ApplicationPlatform],
                 [txInserted],
                 [txInsertedSid],
                 [txInsertedUserOriginal],
                 [txInsertedUserExecute],
                 [txInsertedHost],
                 [txRowReplication]
        FROM     [track].[ApplicationLogBegin]
        ORDER BY [ApplicationLogId] ASC;
        SET IDENTITY_INSERT [track].[tmp_ms_xx_ApplicationLogBegin] OFF;
    END

DROP TABLE [track].[ApplicationLogBegin];

EXECUTE sp_rename N'[track].[tmp_ms_xx_ApplicationLogBegin]', N'ApplicationLogBegin';

EXECUTE sp_rename N'[track].[tmp_ms_xx_constraint_PK_ApplicationLogBegin1]', N'PK_ApplicationLogBegin', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [track].[ApplicationLogOrphans]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [track].[tmp_ms_xx_ApplicationLogOrphans] (
    [ApplicationLogId]       INT                NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) CONSTRAINT [DF_ApplicationLogOrphans_txInserted] DEFAULT (SYSDATETIMEOFFSET()) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     CONSTRAINT [DF_ApplicationLogOrphans_txInsertedSid] DEFAULT (SUSER_SID()) NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     CONSTRAINT [DF_ApplicationLogOrphans_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     CONSTRAINT [DF_ApplicationLogOrphans_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     CONSTRAINT [DF_ApplicationLogOrphans_txInsertedHost] DEFAULT (HOST_NAME()) NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     CONSTRAINT [DF_ApplicationLogOrphans_txInsertedApplication] DEFAULT (APP_NAME()) NOT NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   CONSTRAINT [DF_ApplicationLogOrphans_txRowReplication] DEFAULT (NEWSEQUENTIALID()) ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_ApplicationLogOrphans1] PRIMARY KEY CLUSTERED ([ApplicationLogId] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [track].[ApplicationLogOrphans])
    BEGIN
        INSERT INTO [track].[tmp_ms_xx_ApplicationLogOrphans] ([ApplicationLogId], [txInserted], [txInsertedSid], [txInsertedUserOriginal], [txInsertedUserExecute], [txInsertedHost], [txRowReplication])
        SELECT   [ApplicationLogId],
                 [txInserted],
                 [txInsertedSid],
                 [txInsertedUserOriginal],
                 [txInsertedUserExecute],
                 [txInsertedHost],
                 [txRowReplication]
        FROM     [track].[ApplicationLogOrphans]
        ORDER BY [ApplicationLogId] ASC;
    END

DROP TABLE [track].[ApplicationLogOrphans];

EXECUTE sp_rename N'[track].[tmp_ms_xx_ApplicationLogOrphans]', N'ApplicationLogOrphans';

EXECUTE sp_rename N'[track].[tmp_ms_xx_constraint_PK_ApplicationLogOrphans1]', N'PK_ApplicationLogOrphans', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [track].[BatchLogBegin]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [track].[tmp_ms_xx_BatchLogBegin] (
    [BatchLogId]             INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [SchemaName]             NVARCHAR (128)     NOT NULL,
    [TableName]              NVARCHAR (128)     NOT NULL,
    [QualifiedName]          AS                 QUOTENAME([SchemaName]) + N'.' + QUOTENAME([TableName]) PERSISTED NOT NULL,
    [SourceData]             NVARCHAR (128)     NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) CONSTRAINT [DF_BatchLogBegin_txInserted] DEFAULT (SYSDATETIMEOFFSET()) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     CONSTRAINT [DF_BatchLogBegin_txInsertedSid] DEFAULT (SUSER_SID()) NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     CONSTRAINT [DF_BatchLogBegin_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     CONSTRAINT [DF_BatchLogBegin_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     CONSTRAINT [DF_BatchLogBegin_txInsertedHost] DEFAULT (HOST_NAME()) NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     CONSTRAINT [DF_BatchLogBegin_txInsertedApplication] DEFAULT (APP_NAME()) NOT NULL,
    [txInsertedProcedure]    NVARCHAR (517)     CONSTRAINT [DF_BatchLogBegin_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   CONSTRAINT [DF_BatchLogBegin_txRowReplication] DEFAULT (NEWSEQUENTIALID()) ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_BatchLogBegin1] PRIMARY KEY CLUSTERED ([BatchLogId] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [track].[BatchLogBegin])
    BEGIN
        SET IDENTITY_INSERT [track].[tmp_ms_xx_BatchLogBegin] ON;
        INSERT INTO [track].[tmp_ms_xx_BatchLogBegin] ([BatchLogId], [SchemaName], [TableName], [SourceData], [txInserted], [txInsertedSid], [txInsertedUserOriginal], [txInsertedUserExecute], [txInsertedHost], [txRowReplication])
        SELECT   [BatchLogId],
                 [SchemaName],
                 [TableName],
                 [SourceData],
                 [txInserted],
                 [txInsertedSid],
                 [txInsertedUserOriginal],
                 [txInsertedUserExecute],
                 [txInsertedHost],
                 [txRowReplication]
        FROM     [track].[BatchLogBegin]
        ORDER BY [BatchLogId] ASC;
        SET IDENTITY_INSERT [track].[tmp_ms_xx_BatchLogBegin] OFF;
    END

DROP TABLE [track].[BatchLogBegin];

EXECUTE sp_rename N'[track].[tmp_ms_xx_BatchLogBegin]', N'BatchLogBegin';

EXECUTE sp_rename N'[track].[tmp_ms_xx_constraint_PK_BatchLogBegin1]', N'PK_BatchLogBegin', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [track].[BatchLogEnd]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [track].[tmp_ms_xx_BatchLogEnd] (
    [BatchLogId]       INT                NOT NULL,
    [UpdateBeg]        DATETIMEOFFSET (7) NOT NULL,
    [UpdateEnd]        DATETIMEOFFSET (7) NULL,
    [RowCount]         INT                NOT NULL,
    [SourceNotes]      VARCHAR (MAX)      NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) CONSTRAINT [DF_BatchLogEnd_txInserted] DEFAULT (SYSDATETIMEOFFSET()) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   CONSTRAINT [DF_BatchLogEnd_txRowReplication] DEFAULT (NEWSEQUENTIALID()) ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_BatchLogEnd1] PRIMARY KEY CLUSTERED ([BatchLogId] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [track].[BatchLogEnd])
    BEGIN
        INSERT INTO [track].[tmp_ms_xx_BatchLogEnd] ([BatchLogId], [RowCount], [SourceNotes], [txInserted], [txRowReplication])
        SELECT   [BatchLogId],
                 [RowCount],
                 [SourceNotes],
                 [txInserted],
                 [txRowReplication]
        FROM     [track].[BatchLogEnd]
        ORDER BY [BatchLogId] ASC;
    END

DROP TABLE [track].[BatchLogEnd];

EXECUTE sp_rename N'[track].[tmp_ms_xx_BatchLogEnd]', N'BatchLogEnd';

EXECUTE sp_rename N'[track].[tmp_ms_xx_constraint_PK_BatchLogEnd1]', N'PK_BatchLogEnd', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [track].[ProcedureLogBegin]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [track].[tmp_ms_xx_ProcedureLogBegin] (
    [ProcedureLogId]         INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [schema_id]              INT                NOT NULL,
    [object_id]              INT                NOT NULL,
    [SchemaName]             NVARCHAR (128)     NOT NULL,
    [ObjectName]             NVARCHAR (128)     NOT NULL,
    [QualifiedName]          AS                 QUOTENAME([SchemaName]) + N'.' + QUOTENAME([ObjectName]) PERSISTED NOT NULL,
    [SPID]                   SMALLINT           NOT NULL,
    [NestLevel]              INT                NOT NULL,
    [TransactionCount]       INT                NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) CONSTRAINT [DF_ProcedureLogBegin_txInserted] DEFAULT (SYSDATETIMEOFFSET()) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     CONSTRAINT [DF_ProcedureLogBegin_txInsertedSid] DEFAULT (SUSER_SID()) NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     CONSTRAINT [DF_ProcedureLogBegin_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     CONSTRAINT [DF_ProcedureLogBegin_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     CONSTRAINT [DF_ProcedureLogBegin_txInsertedHost] DEFAULT (HOST_NAME()) NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     CONSTRAINT [DF_ProcedureLogBegin_txInsertedApplication] DEFAULT (APP_NAME()) NOT NULL,
    [txInsertedProcedure]    NVARCHAR (517)     CONSTRAINT [DF_ProcedureLogBegin_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   CONSTRAINT [DF_ProcedureLogBegin_txRowReplication] DEFAULT (NEWSEQUENTIALID()) ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_ProcedureLogBegin1] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [track].[ProcedureLogBegin])
    BEGIN
        SET IDENTITY_INSERT [track].[tmp_ms_xx_ProcedureLogBegin] ON;
        INSERT INTO [track].[tmp_ms_xx_ProcedureLogBegin] ([ProcedureLogId], [SchemaName], [ObjectName], [SPID], [NestLevel], [TransactionCount], [txInserted], [txInsertedSid], [txInsertedUserOriginal], [txInsertedUserExecute], [txInsertedHost], [txRowReplication])
        SELECT   [ProcedureLogId],
                 [SchemaName],
                 [ObjectName],
                 [SPID],
                 [NestLevel],
                 [TransactionCount],
                 [txInserted],
                 [txInsertedSid],
                 [txInsertedUserOriginal],
                 [txInsertedUserExecute],
                 [txInsertedHost],
                 [txRowReplication]
        FROM     [track].[ProcedureLogBegin]
        ORDER BY [ProcedureLogId] ASC;
        SET IDENTITY_INSERT [track].[tmp_ms_xx_ProcedureLogBegin] OFF;
    END

DROP TABLE [track].[ProcedureLogBegin];

EXECUTE sp_rename N'[track].[tmp_ms_xx_ProcedureLogBegin]', N'ProcedureLogBegin';

EXECUTE sp_rename N'[track].[tmp_ms_xx_constraint_PK_ProcedureLogBegin1]', N'PK_ProcedureLogBegin', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [track].[ProcedureLogIntermediate]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [track].[tmp_ms_xx_ProcedureLogIntermediate] (
    [ProcedureLogIntermediateId] INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [ProcedureLogId]             INT                NOT NULL,
    [ProcedureLineNumber]        INT                NOT NULL,
    [ProcedureMessage]           VARCHAR (256)      NOT NULL,
    [txInserted]                 DATETIMEOFFSET (7) CONSTRAINT [DF_ProcedureLogIntermediate_txInserted] DEFAULT (SYSDATETIMEOFFSET()) NOT NULL,
    [txInsertedProcedure]        NVARCHAR (517)     CONSTRAINT [DF_ProcedureLogIntermediate_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) NULL,
    [txRowReplication]           UNIQUEIDENTIFIER   CONSTRAINT [DF_ProcedureLogIntermediate_txRowReplication] DEFAULT (NEWSEQUENTIALID()) ROWGUIDCOL NOT NULL,
    [txRowVersion]               ROWVERSION         NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_ProcedureLogIntermediate1] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC, [ProcedureLogIntermediateId] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [track].[ProcedureLogIntermediate])
    BEGIN
        SET IDENTITY_INSERT [track].[tmp_ms_xx_ProcedureLogIntermediate] ON;
        INSERT INTO [track].[tmp_ms_xx_ProcedureLogIntermediate] ([ProcedureLogId], [ProcedureLogIntermediateId], [ProcedureLineNumber], [ProcedureMessage], [txInserted], [txRowReplication])
        SELECT   [ProcedureLogId],
                 [ProcedureLogIntermediateId],
                 [ProcedureLineNumber],
                 [ProcedureMessage],
                 [txInserted],
                 [txRowReplication]
        FROM     [track].[ProcedureLogIntermediate]
        ORDER BY [ProcedureLogId] ASC, [ProcedureLogIntermediateId] ASC;
        SET IDENTITY_INSERT [track].[tmp_ms_xx_ProcedureLogIntermediate] OFF;
    END

DROP TABLE [track].[ProcedureLogIntermediate];

EXECUTE sp_rename N'[track].[tmp_ms_xx_ProcedureLogIntermediate]', N'ProcedureLogIntermediate';

EXECUTE sp_rename N'[track].[tmp_ms_xx_constraint_PK_ProcedureLogIntermediate1]', N'PK_ProcedureLogIntermediate', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [track].[ProcedureLogOrphans]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [track].[tmp_ms_xx_ProcedureLogOrphans] (
    [ProcedureLogId]         INT                NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) CONSTRAINT [DF_ProcedureLogOrphans_txInserted] DEFAULT (SYSDATETIMEOFFSET()) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     CONSTRAINT [DF_ProcedureLogOrphans_txInsertedSid] DEFAULT (SUSER_SID()) NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     CONSTRAINT [DF_ProcedureLogOrphans_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     CONSTRAINT [DF_ProcedureLogOrphans_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     CONSTRAINT [DF_ProcedureLogOrphans_txInsertedHost] DEFAULT (HOST_NAME()) NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     CONSTRAINT [DF_ProcedureLogOrphans_txInsertedApplication] DEFAULT (APP_NAME()) NOT NULL,
    [txInsertedProcedure]    NVARCHAR (517)     CONSTRAINT [DF_ProcedureLogOrphans_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   CONSTRAINT [DF_ProcedureLogOrphans_txRowReplication] DEFAULT (NEWSEQUENTIALID()) ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_ProcedureLogOrphans1] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [track].[ProcedureLogOrphans])
    BEGIN
        INSERT INTO [track].[tmp_ms_xx_ProcedureLogOrphans] ([ProcedureLogId], [txInserted], [txInsertedSid], [txInsertedUserOriginal], [txInsertedUserExecute], [txInsertedHost], [txRowReplication])
        SELECT   [ProcedureLogId],
                 [txInserted],
                 [txInsertedSid],
                 [txInsertedUserOriginal],
                 [txInsertedUserExecute],
                 [txInsertedHost],
                 [txRowReplication]
        FROM     [track].[ProcedureLogOrphans]
        ORDER BY [ProcedureLogId] ASC;
    END

DROP TABLE [track].[ProcedureLogOrphans];

EXECUTE sp_rename N'[track].[tmp_ms_xx_ProcedureLogOrphans]', N'ProcedureLogOrphans';

EXECUTE sp_rename N'[track].[tmp_ms_xx_constraint_PK_ProcedureLogOrphans1]', N'PK_ProcedureLogOrphans', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Creating Table [track].[SsisLogDetail]...';


GO
CREATE TABLE [track].[SsisLogDetail] (
    [SsisLogDetailId]        INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [Event]                  [sysname]          NOT NULL,
    [Computer]               NVARCHAR (128)     NOT NULL,
    [Operator]               NVARCHAR (128)     NOT NULL,
    [Source]                 NVARCHAR (1024)    NOT NULL,
    [SourceId]               UNIQUEIDENTIFIER   NOT NULL,
    [ExecutionId]            UNIQUEIDENTIFIER   NOT NULL,
    [EventBeg]               DATETIME2 (7)      NOT NULL,
    [EventEnd]               DATETIME2 (7)      NOT NULL,
    [DataCode]               INT                NOT NULL,
    [DataBytes]              IMAGE              NOT NULL,
    [Message]                NVARCHAR (2048)    NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApp]          NVARCHAR (128)     NOT NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_SsisLogDetail] PRIMARY KEY CLUSTERED ([SsisLogDetailId] ASC)
);


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInserted]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedSid]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedHost]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedApp]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedApp] DEFAULT (APP_NAME()) FOR [txInsertedApp];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txRowReplication]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Foreign Key [track].[FK_ApplicationLogErrors_Application]...';


GO
ALTER TABLE [track].[ApplicationLogErrors] WITH NOCHECK
    ADD CONSTRAINT [FK_ApplicationLogErrors_Application] FOREIGN KEY ([ApplicationLogId]) REFERENCES [track].[ApplicationLogBegin] ([ApplicationLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ApplicationLogEnd_Application]...';


GO
ALTER TABLE [track].[ApplicationLogEnd] WITH NOCHECK
    ADD CONSTRAINT [FK_ApplicationLogEnd_Application] FOREIGN KEY ([ApplicationLogId]) REFERENCES [track].[ApplicationLogBegin] ([ApplicationLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ApplicationLogOrphans_Application]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans] WITH NOCHECK
    ADD CONSTRAINT [FK_ApplicationLogOrphans_Application] FOREIGN KEY ([ApplicationLogId]) REFERENCES [track].[ApplicationLogBegin] ([ApplicationLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_BatchLogEnd_Batch]...';


GO
ALTER TABLE [track].[BatchLogEnd] WITH NOCHECK
    ADD CONSTRAINT [FK_BatchLogEnd_Batch] FOREIGN KEY ([BatchLogId]) REFERENCES [track].[BatchLogBegin] ([BatchLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogOrphans_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcedureLogOrphans_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogIntermediate_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcedureLogIntermediate_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogErrors_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogErrors] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcedureLogErrors_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogEnd_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogEnd] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcedureLogEnd_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Check Constraint [track].[CL_ProcedureLogBegin_SchemaName]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] WITH NOCHECK
    ADD CONSTRAINT [CL_ProcedureLogBegin_SchemaName] CHECK ([SchemaName] <> N'');


GO
PRINT N'Creating Check Constraint [track].[CL_ProcedureLogBegin_ObjectName]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] WITH NOCHECK
    ADD CONSTRAINT [CL_ProcedureLogBegin_ObjectName] CHECK ([ObjectName] <> N'');


GO
PRINT N'Adding schema binding to [track].[ApplicationLog]...';


GO
ALTER VIEW [track].[ApplicationLog]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
	[b].[ApplicationLogId],

		[database_id]				= DB_ID(),

		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[DatabaseName]				= DB_NAME(),

	[b].[ClassName],
	[b].[FunctionName],

	[b].[ApplicationVersion],
	[b].[ApplicationPlatform],

		[ApplicationUserOriginal]	= [b].[txInsertedUserOriginal],
		[ApplicationUserExecute]	= [b].[txInsertedUserExecute],
		[ApplicationHost]			= [b].[txInsertedHost],
		[ApplicationApplication]	= [b].[txInsertedApplication],

		[ApplicationBegin]			= CONVERT(DATETIME2,	[b].[txInserted]),
		[ApplicationBeginDate]		= CONVERT(DATE,			[b].[txInserted]),
		[ApplicationBeginTime]		= CONVERT(TIME,			[b].[txInserted]),
		[ApplicationBeginZone]		= [b].[txInserted],

		[ApplicationEnd]			= CONVERT(DATETIME2,	[e].[txInserted]),
		[ApplicationEndDate]		= CONVERT(DATE,			[e].[txInserted]),
		[ApplicationEndTime]		= CONVERT(TIME,			[e].[txInserted]),
		[ApplicationEndZone]		= [e].[txInserted],
		
		[ApplicationError]			= CONVERT(DATETIME2,	[r].[txInserted]),
		[ApplicationErrorDate]		= CONVERT(DATE,			[r].[txInserted]),
		[ApplicationErrorTime]		= CONVERT(TIME,			[r].[txInserted]),
		[ApplicationErrorZone]		= [r].[txInserted],
		
		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]), 114), 1, 2, 
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]))),

		[DurationDays]				= DATEDIFF(MINUTE, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted])) / 86400.0,
		[DurationMinutes]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted])) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted])),

	[r].[ErrorMessage]

FROM
	[track].[ApplicationLogBegin]		[b]
LEFT OUTER JOIN
	[track].[ApplicationLogEnd]			[e]
		ON	([b].[ApplicationLogId]	=	[e].[ApplicationLogId])
LEFT OUTER JOIN
	[track].[ApplicationLogErrors]		[r]
		ON	([b].[ApplicationLogId]	=	[r].[ApplicationLogId])
LEFT OUTER JOIN
	[track].[ApplicationLogOrphans]		[o]
		ON	([b].[ApplicationLogId]	=	[o].[ApplicationLogId]);
GO
PRINT N'Adding schema binding to [track].[BatchLog]...';


GO
ALTER VIEW [track].[BatchLog]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
	[b].[BatchLogId],

		[database_id]				= DB_ID(),

		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[DatabaseName]				= DB_NAME(),
	[b].[SchemaName],
	[b].[TableName],
	[b].[SourceData],

		[ApplicationUserOriginal]	= [b].[txInsertedUserOriginal],
		[ApplicationUserExecute]	= [b].[txInsertedUserExecute],
		[ApplicationHost]			= [b].[txInsertedHost],
		[ApplicationApplication]	= [b].[txInsertedApplication],

	[e].[RowCount],
	
		[UpdateBeg]					= CONVERT(DATETIME2,	[e].[UpdateBeg]),
		[UpdateBegDate]				= CONVERT(DATE,			[e].[UpdateBeg]),
		[UpdateBegTime]				= CONVERT(TIME,			[e].[UpdateBeg]),
		[UpdateBegZone]				= [e].[UpdateBeg],

		[UpdateEnd]					= CONVERT(DATETIME2,	[e].[UpdateEnd]),
		[UpdateEndDate]				= CONVERT(DATE,			[e].[UpdateEnd]),
		[UpdateEndTime]				= CONVERT(TIME,			[e].[UpdateEnd]),
		[UpdateEndZone]				= [e].[UpdateEnd],

	[e].[SourceNotes],

		[Duration]					= STUFF(CONVERT(VARCHAR(20),	CONVERT(DATETIME, [e].[txInserted])	- CONVERT(DATETIME, [b].[txInserted]), 114), 1, 2,
											DATEDIFF(HOUR, 0,		CONVERT(DATETIME, [e].[txInserted])	- CONVERT(DATETIME, [b].[txInserted]))),

		[DurationDays]				= DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted]) / 86400.0,
		[DurationMinutes]			= DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted]) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted])

FROM
	[track].[BatchLogBegin]			[b]
LEFT OUTER JOIN
	[track].[BatchLogEnd]			[e]
		ON	([b].[BatchLogId]	=	[e].[BatchLogId]);
GO
PRINT N'Adding schema binding to [track].[ProcedureLogInter]...';


GO
ALTER VIEW [track].[ProcedureLogInter]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
	[b].[ProcedureLogId],

		[database_id]				= DB_ID(),
	[b].[schema_id],
	[b].[object_id],

		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[DatabaseName]				= DB_NAME(),
	[b].[SchemaName],
	[b].[ObjectName],
	[b].[QualifiedName],

		[ProcedureSPID]				= [b].[SPID],
		[ProcedureNestLevel]		= [b].[NestLevel],
		[ProcedureTranCount]		= [b].[TransactionCount],

		[ApplicationUserOriginal]	= [b].[txInsertedUserOriginal],
		[ApplicationUserExecute]	= [b].[txInsertedUserExecute],
		[ProcedureHost]				= [b].[txInsertedHost],
		[ProcedureApplication]		= [b].[txInsertedApplication],

		[ProcedureBeg]				= [b].[txInserted],

		[SegmentEnd]				= [i].[txInserted],

		[DurationMinutes]			= DATEDIFF(SECOND,
										LAG([i].[txInserted], 1, [b].[txInserted]) OVER(PARTITION BY [b].[ProcedureLogId] ORDER BY [i].[txInserted], [i].[ProcedureLogIntermediateId]),
										[i].[txInserted]
										) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND,
										LAG([i].[txInserted], 1, [b].[txInserted]) OVER(PARTITION BY [b].[ProcedureLogId] ORDER BY [i].[txInserted], [i].[ProcedureLogIntermediateId]),
										[i].[txInserted]
										),

	[i].[ProcedureLineNumber],
	[i].[ProcedureMessage]

FROM
	[track].[ProcedureLogBegin]			[b]
LEFT OUTER JOIN
	[track].[ProcedureLogIntermediate]	[i]
		ON	([b].[ProcedureLogId]	=	[i].[ProcedureLogId]);
GO
PRINT N'Creating View [track].[SsisLogPackage]...';


GO
CREATE VIEW [track].[SsisLogPackage]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[Package]			= [t].[txInsertedApp],
		[PackageName]		= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN LEFT([t].[txInsertedApp], CHARINDEX(' (', [t].[txInsertedApp]) - 1)
								ELSE [t].[txInsertedApp]
								END,
		[PackageVersion]	= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN REPLACE(RIGHT([t].[txInsertedApp], LEN([t].[txInsertedApp]) - CHARINDEX(' (', [t].[txInsertedApp]) - 1), ')', '')
								ELSE CONVERT(VARCHAR, NULL)
								END,

		[PackageBeg]		= MIN([t].[EventBeg]),
		[PackageBegDate]	= CONVERT(DATE,			MIN([t].[EventBeg])),
		[PackageBegTime]	= CONVERT(TIME,			MIN([t].[EventBeg])),

		[PackageEnd]		= MAX([t].[EventEnd]),
		[PackageEndDate]	= CONVERT(DATE,			MAX([t].[EventEnd])),
		[PackageEndTime]	= CONVERT(TIME,			MAX([t].[EventEnd])),

		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])), 114), 1, 2,
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])))),

		[DurationDays]		= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventEnd])) / 86400.0,
		[DurationMinutes]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventEnd])) / 60.0,
		[DurationSeconds]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventEnd])),

		[Errors]			= COUNT(CASE WHEN ([t].[Event]	= 'OnError')		THEN 1 END),
		[Warnings]			= COUNT(CASE WHEN ([t].[Event]	= 'OnWarning')		THEN 1 END),
		[Information]		= COUNT(CASE WHEN ([t].[Event]	= 'OnInformation')	THEN 1 END),
		[TasksFailed]		= COUNT(CASE WHEN ([t].[Event]	= 'OnTaskFailed')	THEN 1 END),

		[PackageSources]	= COUNT(DISTINCT [t].[SourceId]),
		[PackageEvents]		= COUNT(*),

	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],

	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp]
FROM
	[track].[SsisLogDetail]	[t]
GROUP BY
	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],
	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp];
GO
PRINT N'Creating View [track].[SsisLogSource]...';


GO
CREATE VIEW [track].[SsisLogSource]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[LogDetailId]		= MIN([SsisLogDetailId]),

		[Package]			= [t].[txInsertedApp],
		[PackageName]		= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN LEFT([t].[txInsertedApp], CHARINDEX(' (', [t].[txInsertedApp]) - 1)
								ELSE [t].[txInsertedApp]
								END,
		[PackageVersion]	= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN REPLACE(RIGHT([t].[txInsertedApp], LEN([t].[txInsertedApp]) - CHARINDEX(' (', [t].[txInsertedApp]) - 1), ')', '')
								ELSE CONVERT(VARCHAR, NULL)
								END,

		[SourceName]		= [t].[Source],

		[SourceBeg]			= MIN([t].[EventBeg]),
		[SourceBegDate]		= CONVERT(DATE,	MIN([t].[EventBeg])),
		[SourceBegTime]		= CONVERT(TIME, MIN([t].[EventBeg])),

		[SourceEnd]			= MAX([t].[EventEnd]),
		[SourceEndDate]		= CONVERT(DATE, MAX([t].[EventEnd])),
		[SourceEndTime]		= CONVERT(TIME, MAX([t].[EventEnd])),

		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])), 114), 1, 2,
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])))),

		[DurationDays]		= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventBeg])) / 86400.0,
		[DurationMinutes]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventBeg])) / 60.0,
		[DurationSeconds]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventBeg])),

		[Errors]			= COUNT(CASE WHEN ([t].[Event]	= 'OnError')		THEN 1 END),
		[Warnings]			= COUNT(CASE WHEN ([t].[Event]	= 'OnWarning')		THEN 1 END),
		[Information]		= COUNT(CASE WHEN ([t].[Event]	= 'OnInformation')	THEN 1 END),
		[TasksFailed]		= COUNT(CASE WHEN ([t].[Event]	= 'OnTaskFailed')	THEN 1 END),

		[SourceEvents]		= COUNT(*),

	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],

	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp]
FROM
	[track].[SsisLogDetail]	[t]
GROUP BY
	[t].[Source],
	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],
	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp];
GO
PRINT N'Altering Function [track].[BatchSize]...';


GO
ALTER FUNCTION [track].[BatchSize]
(
	@ObjectId			INT,
	@MemoryThreshold	FLOAT	= 0.85,
	@TargetRatio		FLOAT	= 1.0
)
RETURNS BIGINT
WITH RETURNS NULL ON NULL INPUT
AS
BEGIN

	DECLARE	@BatchSize	BIGINT;

	DECLARE	@RowCount	BIGINT;
	DECLARE	@Ratio		FLOAT;

	SELECT
		@RowCount	= MAX([p].[rows]),
		@Ratio		= ROUND(
						((@TargetRatio * [s].[committed_target_kb]) + ((1.0 - @TargetRatio) * [s].[committed_kb])) / 8.0 /
						SUM([a].[total_pages])
						, 3)
	FROM
		sys.sql_expression_dependencies		[d]
	INNER JOIN
		sys.objects							[r]
			ON	([d].[referencing_id]	=	[r].[object_id])
			AND	([r].[type]				=	'P')
	INNER JOIN
		sys.objects							[o]
			ON	([d].[referenced_id]	=	[o].[object_id])
			AND	([o].[type]				IN	('U', 'V', 'IT', 'S', 'ET'))
	INNER JOIN
		sys.indexes							[i]
			ON	([o].[object_id]		=	[i].[object_id])
			AND	([i].[is_primary_key]	=	1)
	INNER JOIN
		sys.partitions						[p]
			ON	([i].[object_id]		=	[p].[object_id])
			AND	([i].[index_id]			=	[p].[index_id])
	INNER JOIN
		sys.allocation_units				[a]
			ON	([p].[partition_id]		=	[a].[container_id])
	CROSS JOIN
		sys.dm_os_sys_info					[s]
	WHERE
			([d].[referencing_id]	=	@ObjectId)
		AND	NOT (
				([o].[name]			= LEFT([r].[name], LEN([o].[name])))
			AND	([o].[schema_id]	= [r].[schema_id])
			)
	GROUP BY
		[s].[committed_kb],
		[s].[committed_target_kb];

	SET	@BatchSize = CEILING(@Rowcount * 
			CASE WHEN ((@Ratio - 1.0) > (1.0 - @MemoryThreshold))
			THEN	1.0
			ELSE	CASE WHEN (@Ratio < @MemoryThreshold)
						THEN @Ratio
						ELSE @MemoryThreshold
						END
			END)

	RETURN	@BatchSize;

END;
GO
PRINT N'Altering Function [track].[ProcedureAttributes]...';


GO
ALTER FUNCTION [track].[ProcedureAttributes]
(
	@ExecuteThreshold	INT	=	3
)
RETURNS TABLE
AS
RETURN
(
	SELECT
		[t].[object_id],

		[t].[SchemaName],
		[t].[ObjectName],
			[QualifiedName]	= QUOTENAME([t].[SchemaName]) + N'.' + QUOTENAME([t].[ObjectName]),

			[IsWrapper]		= CONVERT(BIT, CASE WHEN ([track].[StringOccuranceCount]('EXEC', [t].[SqlDef]) > @ExecuteThreshold)
								THEN 1
								ELSE 0
								END),

			[IsDelete]		= CONVERT(BIT, CASE WHEN ([t].[SqlDef] LIKE '%DELETE%FROM%')
								THEN 1
								ELSE 0
								END)
	FROM (
		SELECT
			[p].[object_id],
				[SchemaName]	= [s].[name],
				[ObjectName]	= [p].[name],
				[SqlDef]		= OBJECT_DEFINITION([p].[object_id])
		FROM
			sys.schemas						[s]
		INNER JOIN
			sys.procedures					[p]
				ON	([s].[schema_id]	=	[p].[schema_id])
		) [t]
);
GO
PRINT N'Altering View [track].[ProcedureLog]...';


GO
ALTER VIEW [track].[ProcedureLog]
WITH VIEW_METADATA
AS
SELECT
	[b].[ProcedureLogId],

		[database_id]				= DB_ID(),
	[b].[schema_id],
	[b].[object_id],

		[ServerName]				= @@SERVERNAME,
		[DatabaseName]				= DB_NAME(),
	[b].[SchemaName],
	[b].[ObjectName],
	[b].[QualifiedName],

	[b].[SPID],
	[b].[NestLevel],
	[b].[TransactionCount],

		[ProcedureUserOriginal]		= [b].[txInsertedUserOriginal],
		[ProcedureUserExecute]		= [b].[txInsertedUserExecute],
		[ProcedureHost]				= [b].[txInsertedHost],
		[ProcedureApplication]		= [b].[txInsertedApplication],

		[ProcedureStatus]			= CASE
										WHEN ([e].[txInserted]	IS NOT NULL)	THEN 'Succeeded'
										WHEN ([r].[txInserted]	IS NOT NULL)	THEN 'Failed'
										WHEN ([o].[txInserted]	IS NOT NULL)	THEN 'Ended Unexpectedly'
										ELSE 'Running'
										END,

		[ProcedureBegin]			= CONVERT(DATETIME2,	[b].[txInserted]),
		[ProcedureBeginDate]		= CONVERT(DATE,			[b].[txInserted]),
		[ProcedureBeginTime]		= CONVERT(TIME,			[b].[txInserted]),
		[ProcedureBeginZone]		= [b].[txInserted],

		[ProcedureEnd]				= CONVERT(DATETIME2,	[e].[txInserted]),
		[ProcedureEndDate]			= CONVERT(DATE,			[e].[txInserted]),
		[ProcedureEndTime]			= CONVERT(TIME,			[e].[txInserted]),
		[ProcedureEndZone]			= [e].[txInserted],

		[ProcedureError]			= CONVERT(DATETIME2,	[r].[txInserted]),
		[ProcedureErrorDate]		= CONVERT(DATE,			[r].[txInserted]),
		[ProcedureErrorTime]		= CONVERT(TIME,			[r].[txInserted]),
		[ProcedureErrorZone]		= [r].[txInserted],

		[ProcedureOrphaned]			= CONVERT(DATETIME2,	[o].[txInserted]),
		[ProcedureOrphanedDate]		= CONVERT(DATE,			[o].[txInserted]),
		[ProcedureOrphanedTime]		= CONVERT(TIME,			[o].[txInserted]),
		[ProcedureOrphanedZone]		= [o].[txInserted],

		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]), 114), 1, 2,
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]))),

		[DurationDays]				= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted], IIF([o].[txInserted] IS NULL, SYSDATETIMEOFFSET(), NULL))) / 86400.0,
		[DurationMinutes]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted], IIF([o].[txInserted] IS NULL, SYSDATETIMEOFFSET(), NULL))) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted], IIF([o].[txInserted] IS NULL, SYSDATETIMEOFFSET(), NULL))),

	[r].[ErrorNumber],
	[r].[ErrorSeverity],
	[r].[ErrorState],
	[r].[ErrorProcedure],
	[r].[ErrorLine],
	[r].[ErrorMessage],

		[IsWrapper]					= CONVERT(BIT, COALESCE([a].[IsWrapper], 0)),
		[IsDelete]					= CONVERT(BIT, COALESCE([a].[IsDelete], 0))

FROM
	[track].[ProcedureLogBegin]			[b]
LEFT OUTER JOIN
	[track].[ProcedureLogEnd]			[e]
		ON	([b].[ProcedureLogId]	=	[e].[ProcedureLogId])
LEFT OUTER JOIN
	[track].[ProcedureLogErrors]		[r]
		ON	([b].[ProcedureLogId]	=	[r].[ProcedureLogId])
LEFT OUTER JOIN
	[track].[ProcedureLogOrphans]		[o]
		ON	([b].[ProcedureLogId]	=	[o].[ProcedureLogId])
LEFT OUTER JOIN
	[track].[ProcedureAttributes](3)	[a]
		ON	([b].[object_id]		=	[a].[object_id]);
GO
PRINT N'Altering Procedure [dbo].[sp_ssis_addlogentry]...';


GO
ALTER PROCEDURE [dbo].[sp_ssis_addlogentry]
(
	@event			SYSNAME,
	@computer		NVARCHAR(128),
	@operator		NVARCHAR(128),
	@source			NVARCHAR(1024),
	@sourceid		UNIQUEIDENTIFIER,
	@executionid	UNIQUEIDENTIFIER,
	@starttime		DATETIME2,
	@endtime		DATETIME2,
	@datacode		INT,
	@databytes		IMAGE,
	@message		NVARCHAR(2048)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 1000;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[SsisLogDetail]
		(
			[Event],
			[Computer],
			[Operator],
			[Source],
			[SourceId],
			[ExecutionId],
			[EventBeg],
			[EventEnd],
			[DataCode],
			[DataBytes],
			[Message]
		)
		VALUES
		(
			@event,
			@computer,
			@operator,
			@source,
			@sourceid,
			@executionid,
			@starttime,
			@endtime,
			@datacode,
			@databytes,
			@message
		);

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogBegin]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogBegin]
(
	@ApplicationName		NVARCHAR(128),
	@ClassName				VARCHAR(128),
	@FunctionName			VARCHAR(128),
	@ApplicationVersion		VARCHAR(128),
	@ApplicationPlatform	VARCHAR(128)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @TxnId			NUMERIC(18, 0)	= NULL;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogBegin]
		(
			[txInsertedApplication],
			[ClassName],
			[FunctionName],
			[ApplicationVersion],
			[ApplicationPlatform]
		)
		SELECT
			[txInsertedApplication]	= @ApplicationName,
			[ClassName]				= @ClassName,
			[FunctionName]			= @FunctionName,
			[ApplicationVersion]	= @ApplicationVersion,
			[ApplicationPlatform]	= @ApplicationPlatform;

		SET	@TxnId	= SCOPE_IDENTITY();

	---------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

	END CATCH;

	SELECT [TxnId] = @TxnId;
	RETURN @TxnId;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogEnd]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogEnd]
(
	@ApplicationLogId		INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogEnd]
		(
			[ApplicationLogId]
		)
		SELECT
			[ApplicationLogId] = @ApplicationLogId;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogError]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogError]
(
	@ApplicationLogId	INT,
	@ErrorMessage		VARCHAR(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogErrors]
		(
			[ApplicationLogId],
			[ErrorMessage]
		)
		SELECT
			[ApplicationLogId]	= @ApplicationLogId,
			[ErrorMessage]		= RTRIM(LTRIM(LEFT(@ErrorMessage, 4096)));

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_BatchLogBegin]...';


GO
CREATE PROCEDURE [track].[Insert_BatchLogBegin]
(
	@SchemaName		NVARCHAR(128),
	@TableName		NVARCHAR(128),
	@SourceData		NVARCHAR(128)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @TxnId			NUMERIC(18, 0)	= NULL;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[BatchLogBegin]
		(
			[SchemaName],
			[TableName],
			[SourceData]
		)
		SELECT
			[SchemaName]	= @SchemaName,
			[TableName]		= @TableName,
			[SourceData]	= @SourceData;

		SET	@TxnId	= SCOPE_IDENTITY();

	---------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

	END CATCH;

	SELECT [TxnId] = @TxnId;
	RETURN @TxnId;

END;
GO
PRINT N'Creating Procedure [track].[Insert_BatchLogEnd]...';


GO
CREATE PROCEDURE [track].[Insert_BatchLogEnd]
(
	@BatchLogId			INT,
	@RowCount			INT,
	@UpdateBeg			DATETIMEOFFSET(7),
	@UpdateEnd			DATETIMEOFFSET(7),
	@SourceNotes		VARCHAR(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[BatchLogEnd]
		(
			[BatchLogId],
			[RowCount],
			[UpdateBeg],
			[UpdateEnd],
			[SourceNotes]
		)
		SELECT
			[BatchLogId]		= @BatchLogId,
			[RowCount]			= @RowCount,
			[UpdateBeg]			= @UpdateBeg,
			[UpdateEnd]			= @UpdateEnd,
			[SourceNotes]		= @SourceNotes;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogBegin]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogBegin]
(
	@proc_id				INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @TxnId			NUMERIC(18, 0)	= NULL;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		PRINT CONVERT(NCHAR(23), SYSDATETIME(), 121) + NCHAR(9) + QUOTENAME(OBJECT_SCHEMA_NAME(@proc_id)) + N'.' + QUOTENAME(OBJECT_NAME(@proc_id));
		
		INSERT INTO [track].[ProcedureLogBegin]
		(
			[schema_id],
			[object_id],
			[SchemaName],
			[ObjectName],
			[SPID],
			[NestLevel],
			[TransactionCount]
		)
		SELECT
			[schema_id]			= SCHEMA_ID(OBJECT_SCHEMA_NAME(@proc_id)),
			[object_id]			= @proc_id,
			[SchemaName]		= OBJECT_SCHEMA_NAME(@proc_id),
			[ObjectName]		= OBJECT_NAME(@proc_id),
			[SPID]				= @@SPID,
			[NestLevel]			= @@NESTLEVEL - 1,
			[TransactionCount]	= @@TRANCOUNT - 1;

		SET	@TxnId	= SCOPE_IDENTITY();

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

	END CATCH;

	RETURN @TxnId;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogEnd]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogEnd]
(
	@ProcedureLogId		INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ProcedureLogEnd]
		(
			[ProcedureLogId]
		)
		SELECT
			[ProcedureLogId] = @ProcedureLogId;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogError]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogError]
(
	@ProcedureLogId		INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ProcedureLogErrors]
		(
			[ProcedureLogId],
			[ErrorNumber],
			[ErrorSeverity],
			[ErrorState],
			[ErrorProcedure],
			[ErrorLine],
			[ErrorMessage]
		)
		SELECT
			[ProcedureLogId]	= @ProcedureLogId,
			[ErrorNumber]		= ERROR_NUMBER(),
			[ErrorSeverity]		= ERROR_SEVERITY(),
			[ErrorState]		= ERROR_STATE(),
			[ErrorProcedure]	= COALESCE(ERROR_PROCEDURE(), 'Dynamic SQL'),
			[ErrorLine]			= ERROR_LINE(),
			[ErrorMessage]		= ERROR_MESSAGE();

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogIntermediate]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogIntermediate]
(
	@ObjectId				INT,
	@ProcedureLogId			INT,
	@ProcedureLineId		INT,
	@ProcedureMessage		VARCHAR(256)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	BEGIN TRY
	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	-----------------------------------------------------------------------------------------------

		PRINT CONVERT(NCHAR(23), SYSDATETIME(), 121) + NCHAR(9) + QUOTENAME(OBJECT_SCHEMA_NAME(@ObjectId)) + N'.' + QUOTENAME(OBJECT_NAME(@ObjectId)) + NCHAR(9) + CONVERT(NVARCHAR, @ProcedureLineId) + NCHAR(9) + @ProcedureMessage;

		INSERT INTO [track].[ProcedureLogIntermediate]
		(
			[ProcedureLogId],
			[ProcedureLineNumber],
			[ProcedureMessage]
		)
		SELECT
			[ProcedureLogId]	= @ProcedureLogId,
			[ProcedureLineId]	= @ProcedureLineId,
			[ProcedureMessage]	= @ProcedureMessage;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogOrphan]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogOrphan]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ProcedureLogOrphans]
		(
			[ProcedureLogId]
		)
		SELECT
			[b].[ProcedureLogId]
		FROM
			[track].[ProcedureLogBegin]			[b]	WITH (NOLOCK)
		LEFT OUTER JOIN
			[track].[ProcedureLogEnd]			[e]	WITH (NOLOCK)
				ON	([b].[ProcedureLogId]	=	[e].[ProcedureLogId])
		LEFT OUTER JOIN
			[track].[ProcedureLogErrors]		[r]	WITH (NOLOCK)
				ON	([b].[ProcedureLogId]	=	[r].[ProcedureLogId])
		LEFT OUTER JOIN
			[track].[ProcedureLogOrphans]		[o]	WITH (NOLOCK)
				ON	([b].[ProcedureLogId]	=	[o].[ProcedureLogId])
		WHERE
				([e].[ProcedureLogId]	IS NULL)
			AND	([r].[ProcedureLogId]	IS NULL)
			AND	([o].[ProcedureLogId]	IS NULL)
			AND	([b].[txInserted]		<	GETDATE());

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Altering Procedure [track].[ExampleProcedure]...';


GO
ALTER PROCEDURE [track].[ExampleProcedure]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		DROP TABLE IF EXISTS #TempTable;

		SELECT DB_NAME();

		DECLARE @RandomWait	VARCHAR(8) = CONVERT(VARCHAR(8), DATEADD(SECOND, RAND() * 60 * 10, 0), 108);
		PRINT @RandomWait

		WAITFOR DELAY @RandomWait;

		WAITFOR DELAY '00:00:05';

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Altering Procedure [verf].[InsertItemCount]...';


GO
ALTER PROCEDURE [verf].[InsertItemCount]
(
	@CheckDate		DATETIME	= NULL
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		SET	@CheckDate	= COALESCE(@CheckDate, SYSDATETIME());

		INSERT INTO [verf].[ItemCount]
		(
			[ServerName],
			[DatabaseName],
			[SchemaName],
			[TableName],
			[DescriptionName],
			[CheckDate],
			[Items]
		)
		SELECT
			[ServerName]		= @@SERVERNAME,
			[DatabaseName]		= DB_NAME(),
			[SchemaName]		= 'stg',
			[TableName]			= 'sample',
			[DescriptionName]	= 'sample table insert',
			[CheckDate]			= @CheckDate,
			[Items]				= 1;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogOrphan]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogOrphan]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogOrphans]
		(
			[ApplicationLogId]
		)
		SELECT
			[b].[ApplicationLogId]
		FROM
			[track].[ApplicationLogBegin]		[b]	WITH (NOLOCK)
		LEFT OUTER JOIN
			[track].[ApplicationLogEnd]			[e]	WITH (NOLOCK)
				ON	([b].[ApplicationLogId]	=	[e].[ApplicationLogId])
		LEFT OUTER JOIN
			[track].[ApplicationLogErrors]		[r]	WITH (NOLOCK)
				ON	([b].[ApplicationLogId]	=	[r].[ApplicationLogId])
		LEFT OUTER JOIN
			[track].[ApplicationLogOrphans]		[o]	WITH (NOLOCK)
				ON	([b].[ApplicationLogId]	=	[o].[ApplicationLogId])
		WHERE
				([e].[ApplicationLogId]	IS NULL)
			AND	([r].[ApplicationLogId]	IS NULL)
			AND	([o].[ApplicationLogId]	IS NULL)
			AND	([b].[txInserted]		<	GETDATE());

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [track].[ApplicationLogErrors] WITH CHECK CHECK CONSTRAINT [FK_ApplicationLogErrors_Application];

ALTER TABLE [track].[ApplicationLogEnd] WITH CHECK CHECK CONSTRAINT [FK_ApplicationLogEnd_Application];

ALTER TABLE [track].[ApplicationLogOrphans] WITH CHECK CHECK CONSTRAINT [FK_ApplicationLogOrphans_Application];

ALTER TABLE [track].[BatchLogEnd] WITH CHECK CHECK CONSTRAINT [FK_BatchLogEnd_Batch];

ALTER TABLE [track].[ProcedureLogOrphans] WITH CHECK CHECK CONSTRAINT [FK_ProcedureLogOrphans_Procedure];

ALTER TABLE [track].[ProcedureLogIntermediate] WITH CHECK CHECK CONSTRAINT [FK_ProcedureLogIntermediate_Procedure];

ALTER TABLE [track].[ProcedureLogErrors] WITH CHECK CHECK CONSTRAINT [FK_ProcedureLogErrors_Procedure];

ALTER TABLE [track].[ProcedureLogEnd] WITH CHECK CHECK CONSTRAINT [FK_ProcedureLogEnd_Procedure];

ALTER TABLE [track].[ProcedureLogBegin] WITH CHECK CHECK CONSTRAINT [CL_ProcedureLogBegin_SchemaName];

ALTER TABLE [track].[ProcedureLogBegin] WITH CHECK CHECK CONSTRAINT [CL_ProcedureLogBegin_ObjectName];


GO
PRINT N'Update complete.';


GO
