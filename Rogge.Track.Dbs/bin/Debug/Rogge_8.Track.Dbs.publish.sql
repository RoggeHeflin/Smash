/*
Deployment script for Rogge.Common.Dbs

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "Rogge.Common.Dbs"
:setvar DefaultFilePrefix "Rogge.Common.Dbs"
:setvar DefaultDataPath "D:\Data SQL Server\Data\"
:setvar DefaultLogPath "D:\Data SQL Server\Log\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Creating Table [track].[ApplicationLogBegin]...';


GO
CREATE TABLE [track].[ApplicationLogBegin] (
    [ApplicationLogId]       INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [ClassName]              VARCHAR (128)      NOT NULL,
    [FunctionName]           VARCHAR (128)      NOT NULL,
    [ApplicationVersion]     VARCHAR (128)      NOT NULL,
    [ApplicationPlatform]    VARCHAR (128)      NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     NOT NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ApplicationLogBegin] PRIMARY KEY CLUSTERED ([ApplicationLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ApplicationLogEnd]...';


GO
CREATE TABLE [track].[ApplicationLogEnd] (
    [ApplicationLogId] INT                NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ApplicationLogEnd] PRIMARY KEY CLUSTERED ([ApplicationLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ApplicationLogErrors]...';


GO
CREATE TABLE [track].[ApplicationLogErrors] (
    [ApplicationLogId] INT                NOT NULL,
    [ErrorMessage]     NVARCHAR (MAX)     NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ApplicationLogErrors] PRIMARY KEY CLUSTERED ([ApplicationLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ApplicationLogOrphans]...';


GO
CREATE TABLE [track].[ApplicationLogOrphans] (
    [ApplicationLogId]       INT                NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     NOT NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ApplicationLogOrphans] PRIMARY KEY CLUSTERED ([ApplicationLogId] ASC)
);


GO
PRINT N'Creating Table [track].[BatchLogBegin]...';


GO
CREATE TABLE [track].[BatchLogBegin] (
    [BatchLogId]             INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [SchemaName]             NVARCHAR (128)     NOT NULL,
    [TableName]              NVARCHAR (128)     NOT NULL,
    [QualifiedName]          AS                 QUOTENAME([SchemaName]) + N'.' + QUOTENAME([TableName]) PERSISTED NOT NULL,
    [SourceData]             NVARCHAR (128)     NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     NOT NULL,
    [txInsertedProcedure]    NVARCHAR (517)     NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_BatchLogBegin] PRIMARY KEY CLUSTERED ([BatchLogId] ASC)
);


GO
PRINT N'Creating Table [track].[BatchLogEnd]...';


GO
CREATE TABLE [track].[BatchLogEnd] (
    [BatchLogId]       INT                NOT NULL,
    [UpdateBeg]        DATETIMEOFFSET (7) NOT NULL,
    [UpdateEnd]        DATETIMEOFFSET (7) NULL,
    [RowCount]         INT                NOT NULL,
    [SourceNotes]      VARCHAR (MAX)      NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [PK_BatchLogEnd] PRIMARY KEY CLUSTERED ([BatchLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ProcedureLogBegin]...';


GO
CREATE TABLE [track].[ProcedureLogBegin] (
    [ProcedureLogId]         INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [schema_id]              INT                NOT NULL,
    [object_id]              INT                NOT NULL,
    [SchemaName]             NVARCHAR (128)     NOT NULL,
    [ObjectName]             NVARCHAR (128)     NOT NULL,
    [QualifiedName]          AS                 QUOTENAME([SchemaName]) + N'.' + QUOTENAME([ObjectName]) PERSISTED NOT NULL,
    [SPID]                   SMALLINT           NOT NULL,
    [NestLevel]              INT                NOT NULL,
    [TransactionCount]       INT                NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     NOT NULL,
    [txInsertedProcedure]    NVARCHAR (517)     NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ProcedureLogBegin] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ProcedureLogEnd]...';


GO
CREATE TABLE [track].[ProcedureLogEnd] (
    [ProcedureLogId]   INT                NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ProcedureLogEnd] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ProcedureLogErrors]...';


GO
CREATE TABLE [track].[ProcedureLogErrors] (
    [ProcedureLogId]   INT                NOT NULL,
    [ErrorNumber]      INT                NOT NULL,
    [ErrorSeverity]    INT                NOT NULL,
    [ErrorState]       INT                NOT NULL,
    [ErrorProcedure]   NVARCHAR (128)     NOT NULL,
    [ErrorLine]        INT                NOT NULL,
    [ErrorMessage]     NVARCHAR (MAX)     NOT NULL,
    [txInserted]       DATETIMEOFFSET (7) NOT NULL,
    [txRowReplication] UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]     ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ProcedureLogErrors] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC)
);


GO
PRINT N'Creating Table [track].[ProcedureLogIntermediate]...';


GO
CREATE TABLE [track].[ProcedureLogIntermediate] (
    [ProcedureLogIntermediateId] INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [ProcedureLogId]             INT                NOT NULL,
    [ProcedureLineNumber]        INT                NOT NULL,
    [ProcedureMessage]           VARCHAR (256)      NOT NULL,
    [txInserted]                 DATETIMEOFFSET (7) NOT NULL,
    [txInsertedProcedure]        NVARCHAR (517)     NULL,
    [txRowReplication]           UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]               ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ProcedureLogIntermediate] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC, [ProcedureLogIntermediateId] ASC)
);


GO
PRINT N'Creating Table [track].[ProcedureLogOrphans]...';


GO
CREATE TABLE [track].[ProcedureLogOrphans] (
    [ProcedureLogId]         INT                NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApplication]  NVARCHAR (128)     NOT NULL,
    [txInsertedProcedure]    NVARCHAR (517)     NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_ProcedureLogOrphans] PRIMARY KEY CLUSTERED ([ProcedureLogId] ASC)
);


GO
PRINT N'Creating Table [track].[SsisLogDetail]...';


GO
CREATE TABLE [track].[SsisLogDetail] (
    [SsisLogDetailId]        INT                IDENTITY (1, 1) NOT FOR REPLICATION NOT NULL,
    [Event]                  [sysname]          NOT NULL,
    [Computer]               NVARCHAR (128)     NOT NULL,
    [Operator]               NVARCHAR (128)     NOT NULL,
    [Source]                 NVARCHAR (1024)    NOT NULL,
    [SourceId]               UNIQUEIDENTIFIER   NOT NULL,
    [ExecutionId]            UNIQUEIDENTIFIER   NOT NULL,
    [EventBeg]               DATETIME2 (7)      NOT NULL,
    [EventEnd]               DATETIME2 (7)      NOT NULL,
    [DataCode]               INT                NOT NULL,
    [DataBytes]              IMAGE              NOT NULL,
    [Message]                NVARCHAR (2048)    NOT NULL,
    [txInserted]             DATETIMEOFFSET (7) NOT NULL,
    [txInsertedSid]          VARBINARY (85)     NOT NULL,
    [txInsertedUserOriginal] NVARCHAR (128)     NOT NULL,
    [txInsertedUserExecute]  NVARCHAR (128)     NOT NULL,
    [txInsertedHost]         NVARCHAR (128)     NOT NULL,
    [txInsertedApp]          NVARCHAR (128)     NOT NULL,
    [txRowReplication]       UNIQUEIDENTIFIER   ROWGUIDCOL NOT NULL,
    [txRowVersion]           ROWVERSION         NOT NULL,
    CONSTRAINT [PK_SsisLogDetail] PRIMARY KEY CLUSTERED ([SsisLogDetailId] ASC)
);


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInserted]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInsertedSid]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInsertedHost]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txInsertedApplication]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txInsertedApplication] DEFAULT (APP_NAME()) FOR [txInsertedApplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogBegin_txRowReplication]...';


GO
ALTER TABLE [track].[ApplicationLogBegin]
    ADD CONSTRAINT [DF_ApplicationLogBegin_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogEnd_txInserted]...';


GO
ALTER TABLE [track].[ApplicationLogEnd]
    ADD CONSTRAINT [DF_ApplicationLogEnd_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogEnd_txRowReplication]...';


GO
ALTER TABLE [track].[ApplicationLogEnd]
    ADD CONSTRAINT [DF_ApplicationLogEnd_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogErrors_txInserted]...';


GO
ALTER TABLE [track].[ApplicationLogErrors]
    ADD CONSTRAINT [DF_ApplicationLogErrors_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogErrors_txRowReplication]...';


GO
ALTER TABLE [track].[ApplicationLogErrors]
    ADD CONSTRAINT [DF_ApplicationLogErrors_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInserted]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedSid]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedHost]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txInsertedApplication]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txInsertedApplication] DEFAULT (APP_NAME()) FOR [txInsertedApplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ApplicationLogOrphans_txRowReplication]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans]
    ADD CONSTRAINT [DF_ApplicationLogOrphans_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInserted]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedSid]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedHost]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedApplication]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedApplication] DEFAULT (APP_NAME()) FOR [txInsertedApplication];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txInsertedProcedure]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) FOR [txInsertedProcedure];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogBegin_txRowReplication]...';


GO
ALTER TABLE [track].[BatchLogBegin]
    ADD CONSTRAINT [DF_BatchLogBegin_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogEnd_txInserted]...';


GO
ALTER TABLE [track].[BatchLogEnd]
    ADD CONSTRAINT [DF_BatchLogEnd_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_BatchLogEnd_txRowReplication]...';


GO
ALTER TABLE [track].[BatchLogEnd]
    ADD CONSTRAINT [DF_BatchLogEnd_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedSid]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedHost]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedApplication]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedApplication] DEFAULT (APP_NAME()) FOR [txInsertedApplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txInsertedProcedure]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) FOR [txInsertedProcedure];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogBegin_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogBegin]
    ADD CONSTRAINT [DF_ProcedureLogBegin_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogEnd_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogEnd]
    ADD CONSTRAINT [DF_ProcedureLogEnd_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogEnd_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogEnd]
    ADD CONSTRAINT [DF_ProcedureLogEnd_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogErrors_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogErrors]
    ADD CONSTRAINT [DF_ProcedureLogErrors_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogErrors_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogErrors]
    ADD CONSTRAINT [DF_ProcedureLogErrors_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogIntermediate_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate]
    ADD CONSTRAINT [DF_ProcedureLogIntermediate_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogIntermediate_txInsertedProcedure]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate]
    ADD CONSTRAINT [DF_ProcedureLogIntermediate_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) FOR [txInsertedProcedure];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogIntermediate_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate]
    ADD CONSTRAINT [DF_ProcedureLogIntermediate_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInserted]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedSid]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedHost]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedApplication]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedApplication] DEFAULT (APP_NAME()) FOR [txInsertedApplication];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txInsertedProcedure]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txInsertedProcedure] DEFAULT (QUOTENAME(OBJECT_SCHEMA_NAME(@@PROCID)) + N'.' + QUOTENAME(OBJECT_NAME(@@PROCID))) FOR [txInsertedProcedure];


GO
PRINT N'Creating Default Constraint [track].[DF_ProcedureLogOrphans_txRowReplication]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans]
    ADD CONSTRAINT [DF_ProcedureLogOrphans_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInserted]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInserted] DEFAULT (SYSDATETIMEOFFSET()) FOR [txInserted];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedSid]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedSid] DEFAULT (SUSER_SID()) FOR [txInsertedSid];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedUserOriginal]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedUserOriginal] DEFAULT (ORIGINAL_LOGIN()) FOR [txInsertedUserOriginal];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedUserExecute]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedUserExecute] DEFAULT (SUSER_SNAME()) FOR [txInsertedUserExecute];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedHost]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedHost] DEFAULT (HOST_NAME()) FOR [txInsertedHost];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txInsertedApp]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txInsertedApp] DEFAULT (APP_NAME()) FOR [txInsertedApp];


GO
PRINT N'Creating Default Constraint [track].[DF_SsisLogDetail_txRowReplication]...';


GO
ALTER TABLE [track].[SsisLogDetail]
    ADD CONSTRAINT [DF_SsisLogDetail_txRowReplication] DEFAULT (NEWSEQUENTIALID()) FOR [txRowReplication];


GO
PRINT N'Creating Foreign Key [track].[FK_ApplicationLogEnd_Application]...';


GO
ALTER TABLE [track].[ApplicationLogEnd] WITH NOCHECK
    ADD CONSTRAINT [FK_ApplicationLogEnd_Application] FOREIGN KEY ([ApplicationLogId]) REFERENCES [track].[ApplicationLogBegin] ([ApplicationLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ApplicationLogErrors_Application]...';


GO
ALTER TABLE [track].[ApplicationLogErrors] WITH NOCHECK
    ADD CONSTRAINT [FK_ApplicationLogErrors_Application] FOREIGN KEY ([ApplicationLogId]) REFERENCES [track].[ApplicationLogBegin] ([ApplicationLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ApplicationLogOrphans_Application]...';


GO
ALTER TABLE [track].[ApplicationLogOrphans] WITH NOCHECK
    ADD CONSTRAINT [FK_ApplicationLogOrphans_Application] FOREIGN KEY ([ApplicationLogId]) REFERENCES [track].[ApplicationLogBegin] ([ApplicationLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_BatchLogEnd_Batch]...';


GO
ALTER TABLE [track].[BatchLogEnd] WITH NOCHECK
    ADD CONSTRAINT [FK_BatchLogEnd_Batch] FOREIGN KEY ([BatchLogId]) REFERENCES [track].[BatchLogBegin] ([BatchLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogEnd_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogEnd] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcedureLogEnd_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogErrors_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogErrors] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcedureLogErrors_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogIntermediate_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogIntermediate] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcedureLogIntermediate_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Foreign Key [track].[FK_ProcedureLogOrphans_Procedure]...';


GO
ALTER TABLE [track].[ProcedureLogOrphans] WITH NOCHECK
    ADD CONSTRAINT [FK_ProcedureLogOrphans_Procedure] FOREIGN KEY ([ProcedureLogId]) REFERENCES [track].[ProcedureLogBegin] ([ProcedureLogId]);


GO
PRINT N'Creating Check Constraint [track].[CL_ApplicationLogErrors_ErrorMessage]...';


GO
ALTER TABLE [track].[ApplicationLogErrors] WITH NOCHECK
    ADD CONSTRAINT [CL_ApplicationLogErrors_ErrorMessage] CHECK ([ErrorMessage] <> N'');


GO
PRINT N'Creating Check Constraint [track].[CL_ProcedureLogBegin_SchemaName]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] WITH NOCHECK
    ADD CONSTRAINT [CL_ProcedureLogBegin_SchemaName] CHECK ([SchemaName] <> N'');


GO
PRINT N'Creating Check Constraint [track].[CL_ProcedureLogBegin_ObjectName]...';


GO
ALTER TABLE [track].[ProcedureLogBegin] WITH NOCHECK
    ADD CONSTRAINT [CL_ProcedureLogBegin_ObjectName] CHECK ([ObjectName] <> N'');


GO
PRINT N'Creating Check Constraint [track].[CL_ProcedureLogErrors_ErrorProcedure]...';


GO
ALTER TABLE [track].[ProcedureLogErrors] WITH NOCHECK
    ADD CONSTRAINT [CL_ProcedureLogErrors_ErrorProcedure] CHECK ([ErrorProcedure] <> N'');


GO
PRINT N'Creating Check Constraint [track].[CL_ProcedureLogErrors_ErrorMessage]...';


GO
ALTER TABLE [track].[ProcedureLogErrors] WITH NOCHECK
    ADD CONSTRAINT [CL_ProcedureLogErrors_ErrorMessage] CHECK ([ErrorMessage] <> N'');


GO
PRINT N'Creating View [track].[ApplicationLog]...';


GO
CREATE VIEW [track].[ApplicationLog]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
	[b].[ApplicationLogId],

		[database_id]				= DB_ID(),

		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[DatabaseName]				= DB_NAME(),

	[b].[ClassName],
	[b].[FunctionName],

	[b].[ApplicationVersion],
	[b].[ApplicationPlatform],

		[ApplicationUserOriginal]	= [b].[txInsertedUserOriginal],
		[ApplicationUserExecute]	= [b].[txInsertedUserExecute],
		[ApplicationHost]			= [b].[txInsertedHost],
		[ApplicationApplication]	= [b].[txInsertedApplication],

		[ApplicationBegin]			= CONVERT(DATETIME2,	[b].[txInserted]),
		[ApplicationBeginDate]		= CONVERT(DATE,			[b].[txInserted]),
		[ApplicationBeginTime]		= CONVERT(TIME,			[b].[txInserted]),
		[ApplicationBeginZone]		= [b].[txInserted],

		[ApplicationEnd]			= CONVERT(DATETIME2,	[e].[txInserted]),
		[ApplicationEndDate]		= CONVERT(DATE,			[e].[txInserted]),
		[ApplicationEndTime]		= CONVERT(TIME,			[e].[txInserted]),
		[ApplicationEndZone]		= [e].[txInserted],
		
		[ApplicationError]			= CONVERT(DATETIME2,	[r].[txInserted]),
		[ApplicationErrorDate]		= CONVERT(DATE,			[r].[txInserted]),
		[ApplicationErrorTime]		= CONVERT(TIME,			[r].[txInserted]),
		[ApplicationErrorZone]		= [r].[txInserted],
		
		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]), 114), 1, 2, 
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]))),

		[DurationDays]				= DATEDIFF(MINUTE, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted])) / 86400.0,
		[DurationMinutes]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted])) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted])),

	[r].[ErrorMessage]

FROM
	[track].[ApplicationLogBegin]		[b]
LEFT OUTER JOIN
	[track].[ApplicationLogEnd]			[e]
		ON	([b].[ApplicationLogId]	=	[e].[ApplicationLogId])
LEFT OUTER JOIN
	[track].[ApplicationLogErrors]		[r]
		ON	([b].[ApplicationLogId]	=	[r].[ApplicationLogId])
LEFT OUTER JOIN
	[track].[ApplicationLogOrphans]		[o]
		ON	([b].[ApplicationLogId]	=	[o].[ApplicationLogId]);
GO
PRINT N'Creating View [track].[BatchLog]...';


GO
CREATE VIEW [track].[BatchLog]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
	[b].[BatchLogId],

		[database_id]				= DB_ID(),

		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[DatabaseName]				= DB_NAME(),
	[b].[SchemaName],
	[b].[TableName],
	[b].[SourceData],

		[ApplicationUserOriginal]	= [b].[txInsertedUserOriginal],
		[ApplicationUserExecute]	= [b].[txInsertedUserExecute],
		[ApplicationHost]			= [b].[txInsertedHost],
		[ApplicationApplication]	= [b].[txInsertedApplication],

	[e].[RowCount],
	
		[UpdateBeg]					= CONVERT(DATETIME2,	[e].[UpdateBeg]),
		[UpdateBegDate]				= CONVERT(DATE,			[e].[UpdateBeg]),
		[UpdateBegTime]				= CONVERT(TIME,			[e].[UpdateBeg]),
		[UpdateBegZone]				= [e].[UpdateBeg],

		[UpdateEnd]					= CONVERT(DATETIME2,	[e].[UpdateEnd]),
		[UpdateEndDate]				= CONVERT(DATE,			[e].[UpdateEnd]),
		[UpdateEndTime]				= CONVERT(TIME,			[e].[UpdateEnd]),
		[UpdateEndZone]				= [e].[UpdateEnd],

	[e].[SourceNotes],

		[Duration]					= STUFF(CONVERT(VARCHAR(20),	CONVERT(DATETIME, [e].[txInserted])	- CONVERT(DATETIME, [b].[txInserted]), 114), 1, 2,
											DATEDIFF(HOUR, 0,		CONVERT(DATETIME, [e].[txInserted])	- CONVERT(DATETIME, [b].[txInserted]))),

		[DurationDays]				= DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted]) / 86400.0,
		[DurationMinutes]			= DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted]) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND, [b].[txInserted], [e].[txInserted])

FROM
	[track].[BatchLogBegin]			[b]
LEFT OUTER JOIN
	[track].[BatchLogEnd]			[e]
		ON	([b].[BatchLogId]	=	[e].[BatchLogId]);
GO
PRINT N'Creating View [track].[ProcedureLogInter]...';


GO
CREATE VIEW [track].[ProcedureLogInter]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
	[b].[ProcedureLogId],

		[database_id]				= DB_ID(),
	[b].[schema_id],
	[b].[object_id],

		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[DatabaseName]				= DB_NAME(),
	[b].[SchemaName],
	[b].[ObjectName],
	[b].[QualifiedName],

		[ProcedureSPID]				= [b].[SPID],
		[ProcedureNestLevel]		= [b].[NestLevel],
		[ProcedureTranCount]		= [b].[TransactionCount],

		[ApplicationUserOriginal]	= [b].[txInsertedUserOriginal],
		[ApplicationUserExecute]	= [b].[txInsertedUserExecute],
		[ProcedureHost]				= [b].[txInsertedHost],
		[ProcedureApplication]		= [b].[txInsertedApplication],

		[ProcedureBeg]				= [b].[txInserted],

		[SegmentEnd]				= [i].[txInserted],

		[DurationMinutes]			= DATEDIFF(SECOND,
										LAG([i].[txInserted], 1, [b].[txInserted]) OVER(PARTITION BY [b].[ProcedureLogId] ORDER BY [i].[txInserted], [i].[ProcedureLogIntermediateId]),
										[i].[txInserted]
										) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND,
										LAG([i].[txInserted], 1, [b].[txInserted]) OVER(PARTITION BY [b].[ProcedureLogId] ORDER BY [i].[txInserted], [i].[ProcedureLogIntermediateId]),
										[i].[txInserted]
										),

	[i].[ProcedureLineNumber],
	[i].[ProcedureMessage]

FROM
	[track].[ProcedureLogBegin]			[b]
LEFT OUTER JOIN
	[track].[ProcedureLogIntermediate]	[i]
		ON	([b].[ProcedureLogId]	=	[i].[ProcedureLogId]);
GO
PRINT N'Creating View [track].[SsisLogPackage]...';


GO
CREATE VIEW [track].[SsisLogPackage]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[Package]			= [t].[txInsertedApp],
		[PackageName]		= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN LEFT([t].[txInsertedApp], CHARINDEX(' (', [t].[txInsertedApp]) - 1)
								ELSE [t].[txInsertedApp]
								END,
		[PackageVersion]	= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN REPLACE(RIGHT([t].[txInsertedApp], LEN([t].[txInsertedApp]) - CHARINDEX(' (', [t].[txInsertedApp]) - 1), ')', '')
								ELSE CONVERT(VARCHAR, NULL)
								END,

		[PackageBeg]		= MIN([t].[EventBeg]),
		[PackageBegDate]	= CONVERT(DATE,			MIN([t].[EventBeg])),
		[PackageBegTime]	= CONVERT(TIME,			MIN([t].[EventBeg])),

		[PackageEnd]		= MAX([t].[EventEnd]),
		[PackageEndDate]	= CONVERT(DATE,			MAX([t].[EventEnd])),
		[PackageEndTime]	= CONVERT(TIME,			MAX([t].[EventEnd])),

		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])), 114), 1, 2,
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])))),

		[DurationDays]		= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventEnd])) / 86400.0,
		[DurationMinutes]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventEnd])) / 60.0,
		[DurationSeconds]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventEnd])),

		[Errors]			= COUNT(CASE WHEN ([t].[Event]	= 'OnError')		THEN 1 END),
		[Warnings]			= COUNT(CASE WHEN ([t].[Event]	= 'OnWarning')		THEN 1 END),
		[Information]		= COUNT(CASE WHEN ([t].[Event]	= 'OnInformation')	THEN 1 END),
		[TasksFailed]		= COUNT(CASE WHEN ([t].[Event]	= 'OnTaskFailed')	THEN 1 END),

		[PackageSources]	= COUNT(DISTINCT [t].[SourceId]),
		[PackageEvents]		= COUNT(*),

	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],

	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp]
FROM
	[track].[SsisLogDetail]	[t]
GROUP BY
	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],
	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp];
GO
PRINT N'Creating View [track].[SsisLogSource]...';


GO
CREATE VIEW [track].[SsisLogSource]
WITH SCHEMABINDING, VIEW_METADATA
AS
SELECT
		[Instance]					= @@SERVERNAME,
		[InstanceHost]				= CAST(SERVERPROPERTY('MachineName') AS VARCHAR),
		[InstanceName]				= @@SERVICENAME,

		[LogDetailId]		= MIN([SsisLogDetailId]),

		[Package]			= [t].[txInsertedApp],
		[PackageName]		= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN LEFT([t].[txInsertedApp], CHARINDEX(' (', [t].[txInsertedApp]) - 1)
								ELSE [t].[txInsertedApp]
								END,
		[PackageVersion]	= CASE WHEN ([t].[txInsertedApp] LIKE N'%(%)')
								THEN REPLACE(RIGHT([t].[txInsertedApp], LEN([t].[txInsertedApp]) - CHARINDEX(' (', [t].[txInsertedApp]) - 1), ')', '')
								ELSE CONVERT(VARCHAR, NULL)
								END,

		[SourceName]		= [t].[Source],

		[SourceBeg]			= MIN([t].[EventBeg]),
		[SourceBegDate]		= CONVERT(DATE,	MIN([t].[EventBeg])),
		[SourceBegTime]		= CONVERT(TIME, MIN([t].[EventBeg])),

		[SourceEnd]			= MAX([t].[EventEnd]),
		[SourceEndDate]		= CONVERT(DATE, MAX([t].[EventEnd])),
		[SourceEndTime]		= CONVERT(TIME, MAX([t].[EventEnd])),

		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])), 114), 1, 2,
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, MAX([t].[EventEnd])) - CONVERT(DATETIME, MIN([t].[EventBeg])))),

		[DurationDays]		= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventBeg])) / 86400.0,
		[DurationMinutes]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventBeg])) / 60.0,
		[DurationSeconds]	= DATEDIFF(SECOND, MIN([t].[EventBeg]), MAX([t].[EventBeg])),

		[Errors]			= COUNT(CASE WHEN ([t].[Event]	= 'OnError')		THEN 1 END),
		[Warnings]			= COUNT(CASE WHEN ([t].[Event]	= 'OnWarning')		THEN 1 END),
		[Information]		= COUNT(CASE WHEN ([t].[Event]	= 'OnInformation')	THEN 1 END),
		[TasksFailed]		= COUNT(CASE WHEN ([t].[Event]	= 'OnTaskFailed')	THEN 1 END),

		[SourceEvents]		= COUNT(*),

	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],

	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp]
FROM
	[track].[SsisLogDetail]	[t]
GROUP BY
	[t].[Source],
	[t].[Computer],
	[t].[Operator],
	[t].[ExecutionId],
	[t].[txInsertedSid],
	[t].[txInsertedUserOriginal],
	[t].[txInsertedUserExecute],
	[t].[txInsertedHost],
	[t].[txInsertedApp];
GO
PRINT N'Altering Function [track].[BatchSize]...';


GO
ALTER FUNCTION [track].[BatchSize]
(
	@ObjectId			INT,
	@MemoryThreshold	FLOAT	= 0.85,
	@TargetRatio		FLOAT	= 1.0
)
RETURNS BIGINT
WITH RETURNS NULL ON NULL INPUT
AS
BEGIN

	DECLARE	@BatchSize	BIGINT;

	DECLARE	@RowCount	BIGINT;
	DECLARE	@Ratio		FLOAT;

	SELECT
		@RowCount	= MAX([p].[rows]),
		@Ratio		= ROUND(
						((@TargetRatio * [s].[committed_target_kb]) + ((1.0 - @TargetRatio) * [s].[committed_kb])) / 8.0 /
						SUM([a].[total_pages])
						, 3)
	FROM
		sys.sql_expression_dependencies		[d]
	INNER JOIN
		sys.objects							[r]
			ON	([d].[referencing_id]	=	[r].[object_id])
			AND	([r].[type]				=	'P')
	INNER JOIN
		sys.objects							[o]
			ON	([d].[referenced_id]	=	[o].[object_id])
			AND	([o].[type]				IN	('U', 'V', 'IT', 'S', 'ET'))
	INNER JOIN
		sys.indexes							[i]
			ON	([o].[object_id]		=	[i].[object_id])
			AND	([i].[is_primary_key]	=	1)
	INNER JOIN
		sys.partitions						[p]
			ON	([i].[object_id]		=	[p].[object_id])
			AND	([i].[index_id]			=	[p].[index_id])
	INNER JOIN
		sys.allocation_units				[a]
			ON	([p].[partition_id]		=	[a].[container_id])
	CROSS JOIN
		sys.dm_os_sys_info					[s]
	WHERE
			([d].[referencing_id]	=	@ObjectId)
		AND	NOT (
				([o].[name]			= LEFT([r].[name], LEN([o].[name])))
			AND	([o].[schema_id]	= [r].[schema_id])
			)
	GROUP BY
		[s].[committed_kb],
		[s].[committed_target_kb];

	SET	@BatchSize = CEILING(@Rowcount * 
			CASE WHEN ((@Ratio - 1.0) > (1.0 - @MemoryThreshold))
			THEN	1.0
			ELSE	CASE WHEN (@Ratio < @MemoryThreshold)
						THEN @Ratio
						ELSE @MemoryThreshold
						END
			END)

	RETURN	@BatchSize;

END;
GO
PRINT N'Altering Function [track].[ProcedureAttributes]...';


GO
ALTER FUNCTION [track].[ProcedureAttributes]
(
	@ExecuteThreshold	INT	=	3
)
RETURNS TABLE
AS
RETURN
(
	SELECT
		[t].[object_id],

		[t].[SchemaName],
		[t].[ObjectName],
			[QualifiedName]	= QUOTENAME([t].[SchemaName]) + N'.' + QUOTENAME([t].[ObjectName]),

			[IsWrapper]		= CONVERT(BIT, CASE WHEN ([track].[StringOccuranceCount]('EXEC', [t].[SqlDef]) > @ExecuteThreshold)
								THEN 1
								ELSE 0
								END),

			[IsDelete]		= CONVERT(BIT, CASE WHEN ([t].[SqlDef] LIKE '%DELETE%FROM%')
								THEN 1
								ELSE 0
								END)
	FROM (
		SELECT
			[p].[object_id],
				[SchemaName]	= [s].[name],
				[ObjectName]	= [p].[name],
				[SqlDef]		= OBJECT_DEFINITION([p].[object_id])
		FROM
			sys.schemas						[s]
		INNER JOIN
			sys.procedures					[p]
				ON	([s].[schema_id]	=	[p].[schema_id])
		) [t]
);
GO
PRINT N'Altering View [track].[ProcedureLog]...';


GO
ALTER VIEW [track].[ProcedureLog]
WITH VIEW_METADATA
AS
SELECT
	[b].[ProcedureLogId],

		[database_id]				= DB_ID(),
	[b].[schema_id],
	[b].[object_id],

		[ServerName]				= @@SERVERNAME,
		[DatabaseName]				= DB_NAME(),
	[b].[SchemaName],
	[b].[ObjectName],
	[b].[QualifiedName],

	[b].[SPID],
	[b].[NestLevel],
	[b].[TransactionCount],

		[ProcedureUserOriginal]		= [b].[txInsertedUserOriginal],
		[ProcedureUserExecute]		= [b].[txInsertedUserExecute],
		[ProcedureHost]				= [b].[txInsertedHost],
		[ProcedureApplication]		= [b].[txInsertedApplication],

		[ProcedureStatus]			= CASE
										WHEN ([e].[txInserted]	IS NOT NULL)	THEN 'Succeeded'
										WHEN ([r].[txInserted]	IS NOT NULL)	THEN 'Failed'
										WHEN ([o].[txInserted]	IS NOT NULL)	THEN 'Ended Unexpectedly'
										ELSE 'Running'
										END,

		[ProcedureBegin]			= CONVERT(DATETIME2,	[b].[txInserted]),
		[ProcedureBeginDate]		= CONVERT(DATE,			[b].[txInserted]),
		[ProcedureBeginTime]		= CONVERT(TIME,			[b].[txInserted]),
		[ProcedureBeginZone]		= [b].[txInserted],

		[ProcedureEnd]				= CONVERT(DATETIME2,	[e].[txInserted]),
		[ProcedureEndDate]			= CONVERT(DATE,			[e].[txInserted]),
		[ProcedureEndTime]			= CONVERT(TIME,			[e].[txInserted]),
		[ProcedureEndZone]			= [e].[txInserted],

		[ProcedureError]			= CONVERT(DATETIME2,	[r].[txInserted]),
		[ProcedureErrorDate]		= CONVERT(DATE,			[r].[txInserted]),
		[ProcedureErrorTime]		= CONVERT(TIME,			[r].[txInserted]),
		[ProcedureErrorZone]		= [r].[txInserted],

		[ProcedureOrphaned]			= CONVERT(DATETIME2,	[o].[txInserted]),
		[ProcedureOrphanedDate]		= CONVERT(DATE,			[o].[txInserted]),
		[ProcedureOrphanedTime]		= CONVERT(TIME,			[o].[txInserted]),
		[ProcedureOrphanedZone]		= [o].[txInserted],

		[Duration]					= STUFF(CONVERT(VARCHAR(20), CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]), 114), 1, 2,
											DATEDIFF(HOUR, 0,	 CONVERT(DATETIME, COALESCE([e].[txInserted], [r].[txInserted])) - CONVERT(DATETIME, [b].[txInserted]))),

		[DurationDays]				= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted], IIF([o].[txInserted] IS NULL, SYSDATETIMEOFFSET(), NULL))) / 86400.0,
		[DurationMinutes]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted], IIF([o].[txInserted] IS NULL, SYSDATETIMEOFFSET(), NULL))) / 60.0,
		[DurationSeconds]			= DATEDIFF(SECOND, [b].[txInserted], COALESCE([e].[txInserted], [r].[txInserted], IIF([o].[txInserted] IS NULL, SYSDATETIMEOFFSET(), NULL))),

	[r].[ErrorNumber],
	[r].[ErrorSeverity],
	[r].[ErrorState],
	[r].[ErrorProcedure],
	[r].[ErrorLine],
	[r].[ErrorMessage],

		[IsWrapper]					= CONVERT(BIT, COALESCE([a].[IsWrapper], 0)),
		[IsDelete]					= CONVERT(BIT, COALESCE([a].[IsDelete], 0))

FROM
	[track].[ProcedureLogBegin]			[b]
LEFT OUTER JOIN
	[track].[ProcedureLogEnd]			[e]
		ON	([b].[ProcedureLogId]	=	[e].[ProcedureLogId])
LEFT OUTER JOIN
	[track].[ProcedureLogErrors]		[r]
		ON	([b].[ProcedureLogId]	=	[r].[ProcedureLogId])
LEFT OUTER JOIN
	[track].[ProcedureLogOrphans]		[o]
		ON	([b].[ProcedureLogId]	=	[o].[ProcedureLogId])
LEFT OUTER JOIN
	[track].[ProcedureAttributes](3)	[a]
		ON	([b].[object_id]		=	[a].[object_id]);
GO
PRINT N'Altering Procedure [dbo].[sp_ssis_addlogentry]...';


GO
ALTER PROCEDURE [dbo].[sp_ssis_addlogentry]
(
	@event			SYSNAME,
	@computer		NVARCHAR(128),
	@operator		NVARCHAR(128),
	@source			NVARCHAR(1024),
	@sourceid		UNIQUEIDENTIFIER,
	@executionid	UNIQUEIDENTIFIER,
	@starttime		DATETIME2,
	@endtime		DATETIME2,
	@datacode		INT,
	@databytes		IMAGE,
	@message		NVARCHAR(2048)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 1000;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[SsisLogDetail]
		(
			[Event],
			[Computer],
			[Operator],
			[Source],
			[SourceId],
			[ExecutionId],
			[EventBeg],
			[EventEnd],
			[DataCode],
			[DataBytes],
			[Message]
		)
		VALUES
		(
			@event,
			@computer,
			@operator,
			@source,
			@sourceid,
			@executionid,
			@starttime,
			@endtime,
			@datacode,
			@databytes,
			@message
		);

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogBegin]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogBegin]
(
	@ApplicationName		NVARCHAR(128),
	@ClassName				VARCHAR(128),
	@FunctionName			VARCHAR(128),
	@ApplicationVersion		VARCHAR(128),
	@ApplicationPlatform	VARCHAR(128)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @TxnId			NUMERIC(18, 0)	= NULL;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogBegin]
		(
			[txInsertedApplication],
			[ClassName],
			[FunctionName],
			[ApplicationVersion],
			[ApplicationPlatform]
		)
		SELECT
			[txInsertedApplication]	= @ApplicationName,
			[ClassName]				= @ClassName,
			[FunctionName]			= @FunctionName,
			[ApplicationVersion]	= @ApplicationVersion,
			[ApplicationPlatform]	= @ApplicationPlatform;

		SET	@TxnId	= SCOPE_IDENTITY();

	---------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

	END CATCH;

	SELECT [TxnId] = @TxnId;
	RETURN @TxnId;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogEnd]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogEnd]
(
	@ApplicationLogId		INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogEnd]
		(
			[ApplicationLogId]
		)
		SELECT
			[ApplicationLogId] = @ApplicationLogId;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogError]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogError]
(
	@ApplicationLogId	INT,
	@ErrorMessage		VARCHAR(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogErrors]
		(
			[ApplicationLogId],
			[ErrorMessage]
		)
		SELECT
			[ApplicationLogId]	= @ApplicationLogId,
			[ErrorMessage]		= RTRIM(LTRIM(LEFT(@ErrorMessage, 4096)));

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_BatchLogBegin]...';


GO
CREATE PROCEDURE [track].[Insert_BatchLogBegin]
(
	@SchemaName		NVARCHAR(128),
	@TableName		NVARCHAR(128),
	@SourceData		NVARCHAR(128)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @TxnId			NUMERIC(18, 0)	= NULL;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[BatchLogBegin]
		(
			[SchemaName],
			[TableName],
			[SourceData]
		)
		SELECT
			[SchemaName]	= @SchemaName,
			[TableName]		= @TableName,
			[SourceData]	= @SourceData;

		SET	@TxnId	= SCOPE_IDENTITY();

	---------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

	END CATCH;

	SELECT [TxnId] = @TxnId;
	RETURN @TxnId;

END;
GO
PRINT N'Creating Procedure [track].[Insert_BatchLogEnd]...';


GO
CREATE PROCEDURE [track].[Insert_BatchLogEnd]
(
	@BatchLogId			INT,
	@RowCount			INT,
	@UpdateBeg			DATETIMEOFFSET(7),
	@UpdateEnd			DATETIMEOFFSET(7),
	@SourceNotes		VARCHAR(MAX)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[BatchLogEnd]
		(
			[BatchLogId],
			[RowCount],
			[UpdateBeg],
			[UpdateEnd],
			[SourceNotes]
		)
		SELECT
			[BatchLogId]		= @BatchLogId,
			[RowCount]			= @RowCount,
			[UpdateBeg]			= @UpdateBeg,
			[UpdateEnd]			= @UpdateEnd,
			[SourceNotes]		= @SourceNotes;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogBegin]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogBegin]
(
	@proc_id				INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @TxnId			NUMERIC(18, 0)	= NULL;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		PRINT CONVERT(NCHAR(23), SYSDATETIME(), 121) + NCHAR(9) + QUOTENAME(OBJECT_SCHEMA_NAME(@proc_id)) + N'.' + QUOTENAME(OBJECT_NAME(@proc_id));
		
		INSERT INTO [track].[ProcedureLogBegin]
		(
			[schema_id],
			[object_id],
			[SchemaName],
			[ObjectName],
			[SPID],
			[NestLevel],
			[TransactionCount]
		)
		SELECT
			[schema_id]			= SCHEMA_ID(OBJECT_SCHEMA_NAME(@proc_id)),
			[object_id]			= @proc_id,
			[SchemaName]		= OBJECT_SCHEMA_NAME(@proc_id),
			[ObjectName]		= OBJECT_NAME(@proc_id),
			[SPID]				= @@SPID,
			[NestLevel]			= @@NESTLEVEL - 1,
			[TransactionCount]	= @@TRANCOUNT - 1;

		SET	@TxnId	= SCOPE_IDENTITY();

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;

	END CATCH;

	RETURN @TxnId;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogEnd]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogEnd]
(
	@ProcedureLogId		INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ProcedureLogEnd]
		(
			[ProcedureLogId]
		)
		SELECT
			[ProcedureLogId] = @ProcedureLogId;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogError]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogError]
(
	@ProcedureLogId		INT
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ProcedureLogErrors]
		(
			[ProcedureLogId],
			[ErrorNumber],
			[ErrorSeverity],
			[ErrorState],
			[ErrorProcedure],
			[ErrorLine],
			[ErrorMessage]
		)
		SELECT
			[ProcedureLogId]	= @ProcedureLogId,
			[ErrorNumber]		= ERROR_NUMBER(),
			[ErrorSeverity]		= ERROR_SEVERITY(),
			[ErrorState]		= ERROR_STATE(),
			[ErrorProcedure]	= COALESCE(ERROR_PROCEDURE(), 'Dynamic SQL'),
			[ErrorLine]			= ERROR_LINE(),
			[ErrorMessage]		= ERROR_MESSAGE();

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogIntermediate]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogIntermediate]
(
	@ObjectId				INT,
	@ProcedureLogId			INT,
	@ProcedureLineId		INT,
	@ProcedureMessage		VARCHAR(256)
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	BEGIN TRY
	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	-----------------------------------------------------------------------------------------------

		PRINT CONVERT(NCHAR(23), SYSDATETIME(), 121) + NCHAR(9) + QUOTENAME(OBJECT_SCHEMA_NAME(@ObjectId)) + N'.' + QUOTENAME(OBJECT_NAME(@ObjectId)) + NCHAR(9) + CONVERT(NVARCHAR, @ProcedureLineId) + NCHAR(9) + @ProcedureMessage;

		INSERT INTO [track].[ProcedureLogIntermediate]
		(
			[ProcedureLogId],
			[ProcedureLineNumber],
			[ProcedureMessage]
		)
		SELECT
			[ProcedureLogId]	= @ProcedureLogId,
			[ProcedureLineId]	= @ProcedureLineId,
			[ProcedureMessage]	= @ProcedureMessage;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		THROW;
		
		RETURN @ErrorCode;

	END CATCH;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ProcedureLogOrphan]...';


GO
CREATE PROCEDURE [track].[Insert_ProcedureLogOrphan]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ProcedureLogOrphans]
		(
			[ProcedureLogId]
		)
		SELECT
			[b].[ProcedureLogId]
		FROM
			[track].[ProcedureLogBegin]			[b]	WITH (NOLOCK)
		LEFT OUTER JOIN
			[track].[ProcedureLogEnd]			[e]	WITH (NOLOCK)
				ON	([b].[ProcedureLogId]	=	[e].[ProcedureLogId])
		LEFT OUTER JOIN
			[track].[ProcedureLogErrors]		[r]	WITH (NOLOCK)
				ON	([b].[ProcedureLogId]	=	[r].[ProcedureLogId])
		LEFT OUTER JOIN
			[track].[ProcedureLogOrphans]		[o]	WITH (NOLOCK)
				ON	([b].[ProcedureLogId]	=	[o].[ProcedureLogId])
		WHERE
				([e].[ProcedureLogId]	IS NULL)
			AND	([r].[ProcedureLogId]	IS NULL)
			AND	([o].[ProcedureLogId]	IS NULL)
			AND	([b].[txInserted]		<	GETDATE());

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Altering Procedure [track].[ExampleProcedure]...';


GO
ALTER PROCEDURE [track].[ExampleProcedure]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		DROP TABLE IF EXISTS #TempTable;

		SELECT DB_NAME();

		DECLARE @RandomWait	VARCHAR(8) = CONVERT(VARCHAR(8), DATEADD(SECOND, RAND() * 60 * 10, 0), 108);
		PRINT @RandomWait

		WAITFOR DELAY @RandomWait;

		WAITFOR DELAY '00:00:05';

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Altering Procedure [verf].[InsertItemCount]...';


GO
ALTER PROCEDURE [verf].[InsertItemCount]
(
	@CheckDate		DATETIME	= NULL
)
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		SET	@CheckDate	= COALESCE(@CheckDate, SYSDATETIME());

		INSERT INTO [verf].[ItemCount]
		(
			[ServerName],
			[DatabaseName],
			[SchemaName],
			[TableName],
			[DescriptionName],
			[CheckDate],
			[Items]
		)
		SELECT
			[ServerName]		= @@SERVERNAME,
			[DatabaseName]		= DB_NAME(),
			[SchemaName]		= 'stg',
			[TableName]			= 'sample',
			[DescriptionName]	= 'sample table insert',
			[CheckDate]			= @CheckDate,
			[Items]				= 1;

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Creating Procedure [track].[Insert_ApplicationLogOrphan]...';


GO
CREATE PROCEDURE [track].[Insert_ApplicationLogOrphan]
AS
BEGIN

	SET NOCOUNT ON;
	SET LOCK_TIMEOUT 100;
	SET DEADLOCK_PRIORITY HIGH;

	DECLARE @TxnCount		INT				= @@TRANCOUNT;
	DECLARE @TxnActive		VARCHAR(32)		= REPLACE(CONVERT(VARCHAR(36), NEWID(), 0), '-', '');
	DECLARE @ErrorCode		INT				= 0;

	DECLARE @TrackingLogId	INT;
	EXECUTE @TrackingLogId	= [track].[Insert_ProcedureLogBegin] @@PROCID;

	IF (@TxnCount = 0) BEGIN TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	BEGIN TRY
	-----------------------------------------------------------------------------------------------

		INSERT INTO [track].[ApplicationLogOrphans]
		(
			[ApplicationLogId]
		)
		SELECT
			[b].[ApplicationLogId]
		FROM
			[track].[ApplicationLogBegin]		[b]	WITH (NOLOCK)
		LEFT OUTER JOIN
			[track].[ApplicationLogEnd]			[e]	WITH (NOLOCK)
				ON	([b].[ApplicationLogId]	=	[e].[ApplicationLogId])
		LEFT OUTER JOIN
			[track].[ApplicationLogErrors]		[r]	WITH (NOLOCK)
				ON	([b].[ApplicationLogId]	=	[r].[ApplicationLogId])
		LEFT OUTER JOIN
			[track].[ApplicationLogOrphans]		[o]	WITH (NOLOCK)
				ON	([b].[ApplicationLogId]	=	[o].[ApplicationLogId])
		WHERE
				([e].[ApplicationLogId]	IS NULL)
			AND	([r].[ApplicationLogId]	IS NULL)
			AND	([o].[ApplicationLogId]	IS NULL)
			AND	([b].[txInserted]		<	GETDATE());

	-----------------------------------------------------------------------------------------------
	IF (@TxnCount = 0) COMMIT TRANSACTION @TxnActive ELSE SAVE TRANSACTION @TxnActive;
	END TRY
	BEGIN CATCH

		SET @ErrorCode = @@ERROR;

		IF (XACT_STATE() = -1) ROLLBACK	TRANSACTION	@TxnActive;
		IF (XACT_STATE() =  1) COMMIT	TRANSACTION	@TxnActive;

		EXECUTE [track].[Insert_ProcedureLogError] @TrackingLogId;

		THROW;

		RETURN @ErrorCode;

	END CATCH;

	EXECUTE [track].[Insert_ProcedureLogEnd] @TrackingLogId;

	RETURN @ErrorCode;

END;
GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [track].[ApplicationLogEnd] WITH CHECK CHECK CONSTRAINT [FK_ApplicationLogEnd_Application];

ALTER TABLE [track].[ApplicationLogErrors] WITH CHECK CHECK CONSTRAINT [FK_ApplicationLogErrors_Application];

ALTER TABLE [track].[ApplicationLogOrphans] WITH CHECK CHECK CONSTRAINT [FK_ApplicationLogOrphans_Application];

ALTER TABLE [track].[BatchLogEnd] WITH CHECK CHECK CONSTRAINT [FK_BatchLogEnd_Batch];

ALTER TABLE [track].[ProcedureLogEnd] WITH CHECK CHECK CONSTRAINT [FK_ProcedureLogEnd_Procedure];

ALTER TABLE [track].[ProcedureLogErrors] WITH CHECK CHECK CONSTRAINT [FK_ProcedureLogErrors_Procedure];

ALTER TABLE [track].[ProcedureLogIntermediate] WITH CHECK CHECK CONSTRAINT [FK_ProcedureLogIntermediate_Procedure];

ALTER TABLE [track].[ProcedureLogOrphans] WITH CHECK CHECK CONSTRAINT [FK_ProcedureLogOrphans_Procedure];

ALTER TABLE [track].[ApplicationLogErrors] WITH CHECK CHECK CONSTRAINT [CL_ApplicationLogErrors_ErrorMessage];

ALTER TABLE [track].[ProcedureLogBegin] WITH CHECK CHECK CONSTRAINT [CL_ProcedureLogBegin_SchemaName];

ALTER TABLE [track].[ProcedureLogBegin] WITH CHECK CHECK CONSTRAINT [CL_ProcedureLogBegin_ObjectName];

ALTER TABLE [track].[ProcedureLogErrors] WITH CHECK CHECK CONSTRAINT [CL_ProcedureLogErrors_ErrorProcedure];

ALTER TABLE [track].[ProcedureLogErrors] WITH CHECK CHECK CONSTRAINT [CL_ProcedureLogErrors_ErrorMessage];


GO
PRINT N'Update complete.';


GO
